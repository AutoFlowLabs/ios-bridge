<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>iOS Simulator Control</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
            overflow-x: auto;
        }

        .main-container {
            display: flex;
            gap: 20px;
            min-height: 100vh;
            align-items: flex-start;
        }

        .simulator-section {
            flex-shrink: 0;
            min-width: 400px;
            max-width: 500px;
        }

        .controls-panel {
            flex: 1;
            min-width: 400px;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #container {
            position: relative;
            display: inline-block;
            background: white;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 100%;
            box-sizing: border-box;
        }

        #screen,
        #webrtc-video {
            border: 2px solid #888;
            cursor: crosshair;
            background: #f0f0f0;
            border-radius: 8px;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: optimize-contrast;
            image-rendering: crisp-edges;
            width: 100%;
            height: auto;
            max-width: 100%;
            display: block;
            object-fit: contain;
            /* For video element */
        }

        #webrtc-video {
            /* Ensure WebRTC video has same constraints as canvas */
            max-height: 70vh;
            aspect-ratio: auto;
        }

        #status {
            margin: 10px 0;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            word-wrap: break-word;
            line-height: 1.3;
        }

        .connected {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .disconnected {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .controls-section {
            margin: 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .controls-section h3 {
            margin: 0 0 12px 0;
            color: #333;
            font-size: 16px;
            border-bottom: 2px solid #007bff;
            padding-bottom: 5px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
        }

        .controls-grid-wide {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
        }

        button {
            margin: 0;
            padding: 10px 12px;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-size: 13px;
            transition: background-color 0.2s;
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
        }

        button:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        button:active {
            background-color: #004085;
            transform: translateY(0);
        }

        .mode-toggle button {
            background-color: #28a745;
        }

        .mode-toggle button:hover {
            background-color: #1e7e34;
        }

        /* Active mode button styling */
        .mode-toggle button.active {
            background-color: #007bff !important;
            color: white !important;
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.5);
            transform: none !important;
        }

        .mode-toggle button.active:hover {
            background-color: #0056b3 !important;
        }

        .hardware-buttons button {
            background-color: #6c757d;
        }

        .hardware-buttons button:hover {
            background-color: #545b62;
        }

        .gesture-buttons button {
            background-color: #17a2b8;
        }

        .gesture-buttons button:hover {
            background-color: #117a8b;
        }

        .text-input-section {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .text-input-section input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            flex: 1;
            min-width: 200px;
            font-size: 14px;
        }

        .text-input-section button {
            flex-shrink: 0;
        }

        .swipe-mode {
            background-color: #ffc107 !important;
            color: #000 !important;
        }

        .swipe-mode:hover {
            background-color: #e0a800 !important;
        }

        .system-controls .controls-grid {
            grid-template-columns: repeat(2, 1fr);
        }

        /* WebRTC Quality Section - Hidden by default */
        #webrtc-quality-section {
            display: none;
        }

        #webrtc-quality-section.visible {
            display: block;
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
                align-items: center;
            }

            .simulator-section {
                max-width: 100%;
                width: 100%;
            }

            .controls-panel {
                max-width: 100%;
                width: 100%;
            }
        }

        @media (max-width: 768px) {
            body {
                margin: 10px;
            }

            .controls-grid {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            }

            .controls-grid-wide {
                grid-template-columns: 1fr;
            }

            button {
                font-size: 12px;
                padding: 8px 10px;
            }
        }

        .title-section {
            grid-column: 1 / -1;
            text-align: center;
            margin-bottom: 10px;
        }

        .title-section h1 {
            margin: 0;
            color: #333;
            font-size: 24px;
        }

        .simulator-info {
            font-size: 11px;
            color: #666;
            text-align: center;
            margin-top: 10px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .webrtc-mode {
            background-color: #ff6b35 !important;
            color: white !important;
        }

        .webrtc-mode:hover {
            background-color: #e55a2b !important;
        }

        .stream-quality {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
            text-align: center;
        }

        .latency-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .latency-low {
            background-color: #28a745;
        }

        .latency-medium {
            background-color: #ffc107;
        }

        .latency-high {
            background-color: #dc3545;
        }
    </style>
</head>

<body>
    <div class="title-section">
        <h1>üéÆ iOS Simulator Control - Full Remote</h1>
    </div>

    <div class="main-container">
        <!-- Simulator Section -->
        <div class="simulator-section">
            <div id="status" class="disconnected">Connecting...</div>

            <div id="container">
                <canvas id="screen" width="400" height="600"></canvas>
                <!-- WebRTC video with same constraints -->
                <video id="webrtc-video" style="display: none;" autoplay playsinline muted></video>
                <div class="simulator-info">
                    <div id="dimensionInfo">Loading simulator dimensions...</div>
                    <div class="stream-quality">
                        <div id="qualityInfo"></div>
                        <div id="latencyInfo"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Controls Panel -->
        <div class="controls-panel">
            <div class="controls-section">
                <h3>üì± Stream Mode</h3>
                <div class="mode-toggle controls-grid">
                    <button id="webrtc-btn" onclick="switchMode('webrtc')">üöÄ WebRTC Stream</button>
                    <button id="video-btn" onclick="switchMode('video')" class="active">üé• WebSocket Stream</button>
                    <button id="screenshot-btn" onclick="switchMode('screenshot')">üì∑ Screenshot Mode</button>
                </div>
            </div>

            <!-- WebRTC Quality Section - Only visible in WebRTC mode -->
            <div id="webrtc-quality-section" class="controls-section">
                <h3>üé¨ WebRTC Quality</h3>
                <div class="mode-toggle controls-grid">
                    <button id="quality-medium-btn" onclick="setWebRTCQuality('medium')">üì∫ Medium</button>
                    <button id="quality-high-btn" onclick="setWebRTCQuality('high')" class="active">üèÜ High</button>
                    <button id="quality-ultra-btn" onclick="setWebRTCQuality('ultra')">üíé Ultra</button>
                </div>
                <div style="font-size: 11px; color: #666; margin-top: 8px; text-align: center;">
                    Medium: 45fps/3Mbps | High: 60fps/5Mbps | Ultra: 60fps/8Mbps
                </div>
            </div>

            <div class="controls-section system-controls">
                <h3>üéÆ System Controls</h3>
                <div class="controls-grid">
                    <button onclick="restartPipeline()">üîÑ Restart</button>
                    <button onclick="checkStatus()">üìä Status</button>
                    <button onclick="takeScreenshot()">üîÑ Refresh</button>
                    <button onclick="testTap()">üéØ Test Tap</button>
                </div>
            </div>

            <div class="controls-section hardware-buttons">
                <h3>üîò Hardware Buttons</h3>
                <div class="controls-grid">
                    <button onclick="pressButton('home')">üè† Home</button>
                    <button onclick="pressButton('lock')">üîí Lock</button>
                    <button onclick="pressButton('siri')">üé§ Siri</button>
                    <button onclick="pressButton('side-button')">üì± Side</button>
                    <button onclick="pressButton('apple-pay')">üí≥ Pay</button>
                    <button onclick="pressVolumeButton('up')">üîä Vol+</button>
                    <button onclick="pressVolumeButton('down')">üîâ Vol-</button>
                    <button onclick="pressShakeButton()">üì≥ Shake</button>
                </div>
            </div>

            <div class="controls-section gesture-buttons">
                <h3>üëÜ Gesture Controls</h3>
                <div class="controls-grid-wide">
                    <button id="swipeToggle" onclick="toggleSwipeMode()">‚úã Enable Swipe Mode</button>
                </div>

                <!-- Add a line break for better spacing -->
                <br>

                <div class="controls-grid">
                    <button onclick="quickSwipe('up')">‚¨ÜÔ∏è Up</button>
                    <button onclick="quickSwipe('down')">‚¨áÔ∏è Down</button>
                    <button onclick="quickSwipe('left')">‚¨ÖÔ∏è Left</button>
                    <button onclick="quickSwipe('right')">‚û°Ô∏è Right</button>
                </div>
            </div>

            <div class="controls-section">
                <h3>‚å®Ô∏è Text Input</h3>
                <div class="text-input-section">
                    <input type="text" id="textInput" placeholder="Enter text to type..." maxlength="200">
                    <button onclick="sendText()">üì§ Send</button>
                    <button onclick="clearText()">üóëÔ∏è Clear</button>
                </div>
            </div>

            <div class="controls-section">
                <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
                <div style="font-size: 11px; color: #666; line-height: 1.4;">
                    <strong>W</strong>=WebRTC, <strong>V</strong>=Video, <strong>C</strong>=Screenshot<br>
                    <strong>H</strong>=Home, <strong>L</strong>=Lock, <strong>S</strong>=Siri,
                    <strong>P</strong>=Pay<br>
                    <strong>+/-</strong>=Volume, <strong>K</strong>=Shake, <strong>Space</strong>=Toggle Swipe<br>
                    <strong>Arrow Keys</strong>=Quick Swipes, <strong>Enter</strong>=Send Text
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('screen');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        const textInput = document.getElementById('textInput');
        const swipeToggle = document.getElementById('swipeToggle');
        const dimensionInfo = document.getElementById('dimensionInfo');
        const qualityInfo = document.getElementById('qualityInfo');
        const latencyInfo = document.getElementById('latencyInfo');
        const webrtcVideo = document.getElementById('webrtc-video');
        let currentWebRTCQuality = 'high';


        let currentMode = 'video';
        let videoWs = null;
        let screenshotWs = null;
        let controlWs = null;

        // WebRTC variables
        let webrtcWs = null;
        let peerConnection = null;
        let webrtcStats = {
            bytesReceived: 0,
            framesReceived: 0,
            lastStatsTime: 0,
            latency: 0,
            fps: 0
        };
        let webrtcQualitySettings = {
            fps: 60,
            resolution: 'high',
            bitrate: 5000000  // 5 Mbps
        };


        // Gesture mode
        let swipeMode = false;
        let swipeStart = null;

        // Performance tracking
        let frameCount = 0;
        let lastFrameTime = 0;
        let fpsHistory = [];
        let performanceStats = {
            averageFps: 0,
            frameDrops: 0,
            lastUpdate: 0
        };

        // Coordinate systems
        let pixelWidth = 0, pixelHeight = 0;    // For display
        let pointWidth = 0, pointHeight = 0;    // For taps

        init();

        function init() {
            setupControlWebSocket();
            setupKeyboardShortcuts();
            switchMode('video');
        }


        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if (e.target === textInput) return; // Don't interfere with text input

                switch (e.key) {
                    case 'w': switchMode('webrtc'); break;
                    case 'v': switchMode('video'); break;
                    case 'c': switchMode('screenshot'); break;

                    // These should work in ALL modes
                    case 'h': pressButton('home'); break;
                    case 'l': pressButton('lock'); break;
                    case 's': pressButton('siri'); break;
                    case 'p': pressButton('apple-pay'); break;
                    case '=': case '+': pressVolumeButton('up'); break;
                    case '-': case '_': pressVolumeButton('down'); break;
                    case 'k': pressShakeButton(); break;
                    case 'ArrowUp': e.preventDefault(); quickSwipe('up'); break;
                    case 'ArrowDown': e.preventDefault(); quickSwipe('down'); break;
                    case 'ArrowLeft': e.preventDefault(); quickSwipe('left'); break;
                    case 'ArrowRight': e.preventDefault(); quickSwipe('right'); break;
                    case ' ': e.preventDefault(); toggleSwipeMode(); break;
                }
            });

            // Handle text input with Enter key
            textInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendText();
                }
            });
        }


        function setupControlWebSocket() {
            controlWs = new WebSocket(`ws://${location.hostname}:8000/ws/control`);

            controlWs.onopen = () => {
                console.log('Control WebSocket connected');
            };

            controlWs.onerror = (error) => {
                console.error('Control WebSocket error:', error);
                showTemporaryStatus('Control connection error');
            };

            controlWs.onclose = () => {
                console.log('Control WebSocket disconnected, reconnecting...');
                showTemporaryStatus('Control connection lost, reconnecting...');
                setTimeout(setupControlWebSocket, 2000);
            };
        }


        function switchMode(mode) {
            currentMode = mode;

            // Update button highlighting
            updateModeButtonHighlight(mode);

            // Show/hide WebRTC quality section
            const webrtcQualitySection = document.getElementById('webrtc-quality-section');
            if (mode === 'webrtc') {
                webrtcQualitySection.classList.add('visible');
                // Initialize WebRTC quality button highlighting
                updateWebRTCQualityButtonHighlight(currentWebRTCQuality);
            } else {
                webrtcQualitySection.classList.remove('visible');
            }

            // Clean up existing connections
            if (videoWs) videoWs.close();
            if (screenshotWs) screenshotWs.close();
            if (webrtcWs) webrtcWs.close();
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            // Hide/show appropriate elements
            canvas.style.display = mode === 'webrtc' ? 'none' : 'block';
            webrtcVideo.style.display = mode === 'webrtc' ? 'block' : 'none';

            if (mode === 'video') {
                setupHighPerformanceVideoStream();
            } else if (mode === 'screenshot') {
                setupScreenshotMode();
            } else if (mode === 'webrtc') {
                setupWebRTCStream();
            }
        }

        function updateModeButtonHighlight(currentMode) {
            // Remove active class from all mode buttons
            document.getElementById('webrtc-btn').classList.remove('active');
            document.getElementById('video-btn').classList.remove('active');
            document.getElementById('screenshot-btn').classList.remove('active');

            // Add active class to current mode button
            if (currentMode === 'webrtc') {
                document.getElementById('webrtc-btn').classList.add('active');
            } else if (currentMode === 'video') {
                document.getElementById('video-btn').classList.add('active');
            } else if (currentMode === 'screenshot') {
                document.getElementById('screenshot-btn').classList.add('active');
            }
        }

        function setupHighPerformanceVideoStream() {
            videoWs = new WebSocket(`ws://${location.hostname}:8000/ws/video`);

            videoWs.onopen = () => {
                console.log('Hardware-accelerated video WebSocket connected');
                status.textContent = 'Hardware video stream connecting...';
                status.className = 'connected';
                frameCount = 0;
                frameDropCount = 0;
                lastFrameTime = performance.now();
                isProcessingFrame = false;
            };

            videoWs.onclose = () => {
                status.textContent = 'Video stream disconnected';
                status.className = 'disconnected';
            };

            videoWs.onmessage = (event) => {
                // Drop frames if we're still processing
                if (isProcessingFrame) {
                    frameDropCount++;
                    return;
                }

                isProcessingFrame = true;

                try {
                    const now = performance.now();
                    const data = JSON.parse(event.data);

                    if (data.type === 'video_frame') {
                        frameCount++;

                        // Use requestAnimationFrame for smooth rendering
                        requestAnimationFrame(() => {
                            processVideoFrame(data, now);
                            isProcessingFrame = false;
                        });
                    }
                } catch (error) {
                    console.error('Frame processing error:', error);
                    isProcessingFrame = false;
                }
            };

            videoWs.onerror = (error) => {
                console.error('Video WebSocket error:', error);
                status.textContent = 'Video stream error';
                status.className = 'disconnected';
            };
        }

        function processVideoFrame(data, now) {
            const frameDelta = now - lastFrameTime;
            if (frameDelta > 0) {
                const instantFps = 1000 / frameDelta;
                fpsHistory.push(instantFps);
                if (fpsHistory.length > 20) fpsHistory.shift();

                performanceStats.averageFps = Math.round(
                    fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length
                );
            }
            lastFrameTime = now;

            const img = new Image();
            img.onload = () => {
                pixelWidth = data.pixel_width || data.width || img.width;
                pixelHeight = data.pixel_height || data.height || img.height;
                pointWidth = data.point_width || 390;
                pointHeight = data.point_height || 844;

                // Optimized canvas rendering
                updateCanvasOptimized(img, data);

                // Update status less frequently
                if (frameCount % 60 === 0 || now - performanceStats.lastUpdate > 2000) {
                    const serverFps = data.fps || 0;
                    const modeText = swipeMode ? '‚úã SWIPE MODE' : 'üëÜ TAP MODE';
                    const dropRate = frameDropCount > 0 ? ` (${frameDropCount} drops)` : '';
                    status.textContent = `üé• ${modeText} | Frame: ${frameCount}, Client: ${performanceStats.averageFps}fps, Server: ${serverFps}fps${dropRate}`;
                    performanceStats.lastUpdate = now;
                    frameDropCount = 0; // Reset drop counter
                }
            };

            // Handle JPEG format
            img.src = `data:image/jpeg;base64,${data.data}`;
        }

        function updateCanvasOptimized(img, data) {
            // Calculate display size with better performance
            const containerWidth = canvas.parentElement.clientWidth - 24;
            const devicePixelRatio = Math.min(window.devicePixelRatio || 1, 2); // Cap at 2x for performance
            const aspectRatio = pixelWidth / pixelHeight;

            let displayWidth = Math.min(containerWidth, 450);
            let displayHeight = displayWidth / aspectRatio;

            const maxHeight = window.innerHeight * 0.7;
            if (displayHeight > maxHeight) {
                displayHeight = maxHeight;
                displayWidth = displayHeight * aspectRatio;
            }

            displayWidth = Math.round(displayWidth);
            displayHeight = Math.round(displayHeight);

            // Only resize canvas if dimensions changed
            const newCanvasWidth = displayWidth * devicePixelRatio;
            const newCanvasHeight = displayHeight * devicePixelRatio;

            if (canvas.width !== newCanvasWidth || canvas.height !== newCanvasHeight) {
                canvas.width = newCanvasWidth;
                canvas.height = newCanvasHeight;
                canvas.style.width = displayWidth + 'px';
                canvas.style.height = displayHeight + 'px';

                ctx.scale(devicePixelRatio, devicePixelRatio);
            }

            // Optimized rendering
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.clearRect(0, 0, displayWidth, displayHeight);
            ctx.drawImage(img, 0, 0, displayWidth, displayHeight);

            // Update dimension info
            dimensionInfo.textContent = `Pixels: ${pixelWidth}√ó${pixelHeight} | Points: ${pointWidth}√ó${pointHeight} | Display: ${displayWidth}√ó${displayHeight} | JPEG`;
        }

        // Add frame rate monitoring
        setInterval(() => {
            if (frameCount > 0) {
                console.log(`Performance: ${performanceStats.averageFps}fps average, ${frameDropCount} dropped frames in last 5s`);
            }
        }, 5000);

        function setupScreenshotMode() {
            screenshotWs = new WebSocket(`ws://${location.hostname}:8000/ws/screenshot`);

            screenshotWs.onopen = () => {
                console.log('Screenshot WebSocket connected');
                status.textContent = 'High-quality screenshot mode connected';
                status.className = 'connected';
            };

            screenshotWs.onclose = () => {
                status.textContent = 'Screenshot mode disconnected';
                status.className = 'disconnected';
            };

            screenshotWs.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'screenshot') {
                    const img = new Image();
                    img.onload = () => {
                        pixelWidth = data.pixel_width || data.width || img.width;
                        pixelHeight = data.pixel_height || data.height || img.height;
                        pointWidth = data.point_width || 390;
                        pointHeight = data.point_height || 844;

                        updateCanvasOptimized(img, data);

                        const modeText = swipeMode ? '‚úã SWIPE MODE' : 'üëÜ TAP MODE';
                        status.textContent = `üì∑ ${modeText} | High-quality screenshot | JPEG format`;
                    };
                    img.src = `data:image/jpeg;base64,${data.data}`;
                }
            };
        }
        // Enhanced click/swipe handler (coordinate mapping preserved)
        canvas.onmousedown = (ev) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = ev.clientX - rect.left;
            const clickY = ev.clientY - rect.top;

            if (swipeMode) {
                swipeStart = { x: clickX, y: clickY };
                canvas.style.cursor = 'grab';
            } else {
                handleTap(clickX, clickY);
            }
        };

        canvas.onmouseup = (ev) => {
            if (swipeMode && swipeStart) {
                const rect = canvas.getBoundingClientRect();
                const endX = ev.clientX - rect.left;
                const endY = ev.clientY - rect.top;

                handleSwipe(swipeStart.x, swipeStart.y, endX, endY);
                swipeStart = null;
                canvas.style.cursor = 'crosshair';
            }
        };

        canvas.onmouseleave = () => {
            if (swipeMode) {
                swipeStart = null;
                canvas.style.cursor = 'crosshair';
            }
        };

        function handleTap(clickX, clickY) {
            if (pointWidth > 0 && pointHeight > 0) {
                const displayWidth = parseInt(canvas.style.width);
                const displayHeight = parseInt(canvas.style.height);

                const tapX = Math.round((clickX / displayWidth) * pointWidth);
                const tapY = Math.round((clickY / displayHeight) * pointHeight);

                console.log(`Tap: Display(${Math.round(clickX)}, ${Math.round(clickY)}) -> Point(${tapX}, ${tapY})`);

                if (currentMode === 'screenshot' && screenshotWs) {
                    screenshotWs.send(JSON.stringify({ t: 'tap', x: tapX, y: tapY }));
                } else if (currentMode === 'video' && controlWs) {
                    controlWs.send(JSON.stringify({ t: 'tap', x: tapX, y: tapY }));
                }

                showTemporaryStatus(`Tapped: (${tapX}, ${tapY})`);
            }
        }

        function handleSwipe(startX, startY, endX, endY) {
            if (pointWidth > 0 && pointHeight > 0) {
                const displayWidth = parseInt(canvas.style.width);
                const displayHeight = parseInt(canvas.style.height);

                const startPointX = Math.round((startX / displayWidth) * pointWidth);
                const startPointY = Math.round((startY / displayHeight) * pointHeight);
                const endPointX = Math.round((endX / displayWidth) * pointWidth);
                const endPointY = Math.round((endY / displayHeight) * pointHeight);

                console.log(`Swipe: Point(${startPointX}, ${startPointY}) -> Point(${endPointX}, ${endPointY})`);

                const swipeData = {
                    t: 'swipe',
                    start_x: startPointX,
                    start_y: startPointY,
                    end_x: endPointX,
                    end_y: endPointY,
                    duration: 0.3
                };

                if (currentMode === 'screenshot' && screenshotWs) {
                    screenshotWs.send(JSON.stringify(swipeData));
                } else if (currentMode === 'video' && controlWs) {
                    controlWs.send(JSON.stringify(swipeData));
                }

                showTemporaryStatus(`Swiped: (${startPointX}, ${startPointY}) ‚Üí (${endPointX}, ${endPointY})`);
            }
        }

        function toggleSwipeMode() {
            swipeMode = !swipeMode;
            if (swipeMode) {
                swipeToggle.textContent = 'üëÜ Disable Swipe Mode';
                swipeToggle.className = 'swipe-mode';

                // Update cursor for both canvas and video
                canvas.style.cursor = 'crosshair';
                webrtcVideo.style.cursor = 'crosshair';
            } else {
                swipeToggle.textContent = '‚úã Enable Swipe Mode';
                swipeToggle.className = '';

                // Update cursor for both canvas and video
                canvas.style.cursor = 'crosshair';
                webrtcVideo.style.cursor = 'crosshair';
            }

            const modeText = swipeMode ? '‚úã SWIPE MODE ENABLED' : 'üëÜ TAP MODE ENABLED';
            showTemporaryStatus(modeText);
        }
        function quickSwipe(direction) {
            if (pointWidth === 0 || pointHeight === 0) return;

            const centerX = Math.round(pointWidth / 2);
            const centerY = Math.round(pointHeight / 2);
            const distance = 200;

            let startX, startY, endX, endY;

            switch (direction) {
                case 'up':
                    startX = centerX; startY = centerY + distance;
                    endX = centerX; endY = centerY - distance;
                    break;
                case 'down':
                    startX = centerX; startY = centerY - distance;
                    endX = centerX; endY = centerY + distance;
                    break;
                case 'left':
                    startX = centerX + distance; startY = centerY;
                    endX = centerX - distance; endY = centerY;
                    break;
                case 'right':
                    startX = centerX - distance; startY = centerY;
                    endX = centerX + distance; endY = centerY;
                    break;
            }

            const swipeData = {
                t: 'swipe',
                start_x: startX,
                start_y: startY,
                end_x: endX,
                end_y: endY,
                duration: 0.3
            };
            // Send swipe regardless of mode - always use control WebSocket
            if (controlWs) {
                controlWs.send(JSON.stringify(swipeData));
                showTemporaryStatus(`Quick swipe ${direction} performed`);
            } else {
                showTemporaryStatus(`Control connection not available`);
            }
        }

        function pressButton(button) {
            // Send button press regardless of mode - always use control WebSocket
            console.log(`Button pressed: ${button}`);
            if (controlWs) {
                controlWs.send(JSON.stringify({ t: 'button', button: button }));
                showTemporaryStatus(`${button} button pressed`);
            } else {
                showTemporaryStatus(`Control connection not available`);
            }
        }

        function sendText() {
            const text = textInput.value.trim();
            if (!text) return;

            // Send text regardless of mode - always use control WebSocket  
            if (controlWs) {
                controlWs.send(JSON.stringify({ t: 'text', text: text }));
                showTemporaryStatus(`Text sent: "${text}"`);
                textInput.value = '';
            } else {
                showTemporaryStatus(`Control connection not available`);
            }
        }

        function clearText() {
            textInput.value = '';
        }

        function showTemporaryStatus(message) {
            const oldText = status.textContent;
            const modePrefix = currentMode === 'webrtc' ? 'üöÄ ' :
                currentMode === 'video' ? 'üé• ' : 'üì∑ ';
            status.textContent = modePrefix + message;
            setTimeout(() => {
                if (status.textContent === modePrefix + message) {
                    status.textContent = oldText;
                }
            }, 2000);
        }

        async function takeScreenshot() {
            if (currentMode === 'screenshot' && screenshotWs) {
                screenshotWs.send(JSON.stringify({ t: 'refresh' }));
            } else {
                showTemporaryStatus('Screenshot refresh only works in screenshot mode');
            }
        }

        async function restartPipeline() {
            status.textContent = 'Restarting stream...';
            status.className = 'disconnected';

            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            setTimeout(() => switchMode(currentMode), 1000);
        }

        async function checkStatus() {
            try {
                const resp = await fetch('/status');
                const statusData = await resp.json();

                if (statusData.status === 'healthy') {
                    status.textContent = `System healthy | Video clients: ${statusData.video_clients} | Cache age: ${statusData.cache_age?.toFixed(2)}s`;
                    status.className = 'connected';
                } else {
                    status.textContent = 'System unhealthy';
                    status.className = 'disconnected';
                }
            } catch (error) {
                status.textContent = 'Status check failed';
                status.className = 'disconnected';
            }
        }

        async function testTap() {
            if (pointWidth === 0 || pointHeight === 0) {
                status.textContent = 'No point dimensions available';
                return;
            }

            const centerX = Math.round(pointWidth / 2);
            const centerY = Math.round(pointHeight / 2);

            try {
                const resp = await fetch(`/debug/tap/${centerX}/${centerY}`);
                const result = await resp.json();

                if (result.success) {
                    showTemporaryStatus(`Test tap successful at (${centerX}, ${centerY})`);
                } else {
                    showTemporaryStatus(`Test tap failed: ${result.stderr}`);
                }
            } catch (error) {
                showTemporaryStatus('Test tap failed');
            }
        }

        async function pressVolumeButton(direction) {
            try {
                const resp = await fetch(`/debug/volume-${direction}`);
                const result = await resp.json();

                if (result.success) {
                    showTemporaryStatus(`Volume ${direction} pressed`);
                } else {
                    showTemporaryStatus(`Volume ${direction} failed: ${result.note || result.stderr}`);
                }
            } catch (error) {
                showTemporaryStatus(`Volume ${direction} failed`);
            }
        }

        async function pressShakeButton() {
            try {
                const resp = await fetch('/debug/shake');
                const result = await resp.json();

                if (result.success) {
                    showTemporaryStatus('Device shaken');
                } else {
                    showTemporaryStatus(`Shake failed: ${result.stderr}`);
                }
            } catch (error) {
                showTemporaryStatus('Shake failed');
            }
        }


        async function setupWebRTCStream() {
            status.textContent = 'Initializing high-quality WebRTC stream...';
            status.className = 'connected';

            try {
                // Create WebRTC connection with optimized settings
                peerConnection = new RTCPeerConnection({
                    iceServers: [],
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require'
                });

                // Handle incoming video stream with proper sizing
                peerConnection.ontrack = (event) => {
                    console.log('WebRTC high-quality track received');
                    webrtcVideo.srcObject = event.streams[0];

                    // Wait for video metadata to load, then size it properly
                    webrtcVideo.onloadedmetadata = () => {
                        resizeWebRTCVideo();
                        setupWebRTCInteraction();

                        status.textContent = 'üöÄ WebRTC High-Quality Stream - 60fps Ultra Low Latency';
                        status.className = 'connected';
                    };
                };
                // Enhanced connection state handling
                peerConnection.onconnectionstatechange = () => {
                    console.log('WebRTC connection state:', peerConnection.connectionState);

                    if (peerConnection.connectionState === 'connected') {
                        startWebRTCStatsMonitoring();
                        optimizeWebRTCQuality();
                    } else if (peerConnection.connectionState === 'failed') {
                        status.textContent = 'WebRTC connection failed - retrying...';
                        status.className = 'disconnected';
                        setTimeout(() => setupWebRTCStream(), 2000);
                    }
                };

                // Set up signaling WebSocket
                webrtcWs = new WebSocket(`ws://${location.hostname}:8000/ws/webrtc`);

                webrtcWs.onopen = async () => {
                    console.log('WebRTC signaling connected');

                    // Create offer with quality constraints
                    const offer = await peerConnection.createOffer({
                        offerToReceiveVideo: true,
                        offerToReceiveAudio: false,
                        voiceActivityDetection: false
                    });

                    // Enhance SDP for better quality
                    const enhancedOffer = enhanceSDPForQuality(offer);
                    await peerConnection.setLocalDescription(enhancedOffer);

                    // Send enhanced offer
                    webrtcWs.send(JSON.stringify({
                        type: 'offer',
                        sdp: enhancedOffer.sdp
                    }));
                };

                webrtcWs.onmessage = async (event) => {
                    const data = JSON.parse(event.data);

                    if (data.type === 'answer') {
                        const enhancedAnswer = enhanceSDPForQuality({
                            type: 'answer',
                            sdp: data.sdp
                        });

                        await peerConnection.setRemoteDescription(new RTCSessionDescription(enhancedAnswer));
                    } else if (data.type === 'ice-candidate') {
                        if (data.candidate) {
                            await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                        }
                    }
                };

                webrtcWs.onerror = (error) => {
                    console.error('WebRTC signaling error:', error);
                    status.textContent = 'WebRTC signaling error';
                    status.className = 'disconnected';
                };

                webrtcWs.onclose = () => {
                    console.log('WebRTC signaling disconnected');
                    if (currentMode === 'webrtc') {
                        status.textContent = 'WebRTC disconnected';
                        status.className = 'disconnected';
                    }
                };

            } catch (error) {
                console.error('WebRTC setup error:', error);
                status.textContent = 'WebRTC setup failed';
                status.className = 'disconnected';
            }
        }

        function resizeWebRTCVideo() {
            if (!webrtcVideo.videoWidth || !webrtcVideo.videoHeight) return;

            const containerWidth = webrtcVideo.parentElement.clientWidth - 24; // Account for padding
            const videoAspectRatio = webrtcVideo.videoWidth / webrtcVideo.videoHeight;

            // Calculate display size similar to canvas sizing
            let displayWidth = Math.min(containerWidth, 450);
            let displayHeight = displayWidth / videoAspectRatio;

            const maxHeight = window.innerHeight * 0.7;
            if (displayHeight > maxHeight) {
                displayHeight = maxHeight;
                displayWidth = displayHeight * videoAspectRatio;
            }

            // Apply the calculated size
            webrtcVideo.style.width = Math.round(displayWidth) + 'px';
            webrtcVideo.style.height = Math.round(displayHeight) + 'px';
            webrtcVideo.style.maxWidth = '100%';
            webrtcVideo.style.maxHeight = '70vh';

            console.log(`WebRTC video sized: ${displayWidth}x${displayHeight}`);
        }

        function enhanceSDPForQuality(offer) {
            let sdp = offer.sdp;

            // Increase bitrate
            sdp = sdp.replace(/b=AS:\d+/g, `b=AS:${webrtcQualitySettings.bitrate / 1000}`);

            // Add bitrate constraints if not present
            if (!sdp.includes('b=AS:')) {
                sdp = sdp.replace(/(m=video.*)/g, `$1\r\nb=AS:${webrtcQualitySettings.bitrate / 1000}`);
            }

            // Enhance H.264 parameters for quality
            sdp = sdp.replace(
                /(a=fmtp:\d+ .*profile-level-id=42e01f)/g,
                '$1;max-br=5000;max-mbps=245760;max-fs=8160'
            );

            // Set high frame rate
            sdp = sdp.replace(/(a=framerate:)\d+/g, `$1${webrtcQualitySettings.fps}`);

            // Add frame rate if not present
            if (!sdp.includes('a=framerate:')) {
                sdp = sdp.replace(/(m=video.*)/g, `$1\r\na=framerate:${webrtcQualitySettings.fps}`);
            }

            return {
                type: offer.type,
                sdp: sdp
            };
        }


        // Function to optimize WebRTC quality after connection
        async function optimizeWebRTCQuality() {
            if (!peerConnection) return;

            try {
                const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                if (sender) {
                    const params = sender.getParameters();

                    // Optimize encoding parameters
                    if (params.encodings && params.encodings.length > 0) {
                        params.encodings[0].maxBitrate = webrtcQualitySettings.bitrate;
                        params.encodings[0].maxFramerate = webrtcQualitySettings.fps;
                        params.encodings[0].scaleResolutionDownBy = 1; // No downscaling

                        await sender.setParameters(params);
                        console.log('WebRTC quality parameters optimized');
                    }
                }
            } catch (error) {
                console.error('Failed to optimize WebRTC quality:', error);
            }
        }

        // Update setupWebRTCInteraction to properly handle cursor changes
        function setupWebRTCInteraction() {
            // Set video dimensions for coordinate mapping
            webrtcVideo.onloadedmetadata = () => {
                pixelWidth = webrtcVideo.videoWidth;
                pixelHeight = webrtcVideo.videoHeight;
                pointWidth = 390;  // Default iOS point width
                pointHeight = 844; // Default iOS point height

                updateWebRTCInfo();
            };

            // Mouse events for WebRTC video
            webrtcVideo.onmousedown = (ev) => {
                const rect = webrtcVideo.getBoundingClientRect();
                const clickX = ev.clientX - rect.left;
                const clickY = ev.clientY - rect.top;

                if (swipeMode) {
                    swipeStart = { x: clickX, y: clickY };
                    webrtcVideo.style.cursor = 'grab';
                } else {
                    handleWebRTCTap(clickX, clickY);
                }
            };

            webrtcVideo.onmouseup = (ev) => {
                if (swipeMode && swipeStart) {
                    const rect = webrtcVideo.getBoundingClientRect();
                    const endX = ev.clientX - rect.left;
                    const endY = ev.clientY - rect.top;

                    handleWebRTCSwipe(swipeStart.x, swipeStart.y, endX, endY);
                    swipeStart = null;
                    webrtcVideo.style.cursor = 'crosshair';
                }
            };

            webrtcVideo.onmouseleave = () => {
                if (swipeMode) {
                    swipeStart = null;
                    webrtcVideo.style.cursor = 'crosshair';
                }
            };

            webrtcVideo.style.cursor = 'crosshair';
        }

        function handleWebRTCTap(clickX, clickY) {
            if (pointWidth > 0 && pointHeight > 0) {
                const rect = webrtcVideo.getBoundingClientRect();
                const displayWidth = rect.width;
                const displayHeight = rect.height;

                const tapX = Math.round((clickX / displayWidth) * pointWidth);
                const tapY = Math.round((clickY / displayHeight) * pointHeight);

                console.log(`WebRTC Tap: Display(${Math.round(clickX)}, ${Math.round(clickY)}) -> Point(${tapX}, ${tapY})`);

                // Always use control WebSocket for taps in WebRTC mode
                if (controlWs) {
                    controlWs.send(JSON.stringify({ t: 'tap', x: tapX, y: tapY }));
                    showTemporaryStatus(`WebRTC Tap: (${tapX}, ${tapY})`);
                } else {
                    showTemporaryStatus(`Control connection not available`);
                }
            }
        }

        function handleWebRTCSwipe(startX, startY, endX, endY) {
            if (pointWidth > 0 && pointHeight > 0) {
                const rect = webrtcVideo.getBoundingClientRect();
                const displayWidth = rect.width;
                const displayHeight = rect.height;

                const startPointX = Math.round((startX / displayWidth) * pointWidth);
                const startPointY = Math.round((startY / displayHeight) * pointHeight);
                const endPointX = Math.round((endX / displayWidth) * pointWidth);
                const endPointY = Math.round((endY / displayHeight) * pointHeight);

                console.log(`WebRTC Swipe: Point(${startPointX}, ${startPointY}) -> Point(${endPointX}, ${endPointY})`);

                const swipeData = {
                    t: 'swipe',
                    start_x: startPointX,
                    start_y: startPointY,
                    end_x: endPointX,
                    end_y: endPointY,
                    duration: 0.3
                };

                // Always use control WebSocket for swipes in WebRTC mode
                if (controlWs) {
                    controlWs.send(JSON.stringify(swipeData));
                    showTemporaryStatus(`WebRTC Swipe: (${startPointX}, ${startPointY}) ‚Üí (${endPointX}, ${endPointY})`);
                } else {
                    showTemporaryStatus(`Control connection not available`);
                }
            }
        }

        function startWebRTCStatsMonitoring() {
            if (!peerConnection) return;

            let statsInterval = setInterval(async () => {
                if (!peerConnection || peerConnection.connectionState !== 'connected') {
                    clearInterval(statsInterval);
                    return;
                }

                try {
                    const stats = await peerConnection.getStats();

                    stats.forEach(report => {
                        if (report.type === 'inbound-rtp' && report.mediaType === 'video') {
                            const now = Date.now();
                            const deltaTime = (now - webrtcStats.lastStatsTime) / 1000;

                            if (webrtcStats.lastStatsTime > 0 && deltaTime > 0) {
                                const deltaFrames = report.framesReceived - webrtcStats.framesReceived;
                                const deltaBytes = report.bytesReceived - webrtcStats.bytesReceived;

                                webrtcStats.fps = Math.round(deltaFrames / deltaTime);
                                webrtcStats.bitrate = Math.round((deltaBytes * 8) / deltaTime / 1000); // kbps
                                webrtcStats.resolution = `${report.frameWidth}x${report.frameHeight}`;
                                webrtcStats.framesDropped = report.framesDropped || 0;
                                webrtcStats.jitter = report.jitter || 0;
                            }

                            webrtcStats.framesReceived = report.framesReceived;
                            webrtcStats.bytesReceived = report.bytesReceived;
                            webrtcStats.lastStatsTime = now;

                            updateWebRTCInfo();
                        }
                    });
                } catch (error) {
                    console.error('WebRTC stats error:', error);
                }
            }, 1000);
        }

        function updateWebRTCInfo() {
            if (currentMode !== 'webrtc') return;

            const fps = webrtcStats.fps || 0;
            const bitrate = webrtcStats.bitrate || 0;
            const resolution = webrtcStats.resolution || `${pixelWidth}√ó${pixelHeight}`;
            const dropped = webrtcStats.framesDropped || 0;

            dimensionInfo.textContent = `WebRTC: ${resolution} | Points: ${pointWidth}√ó${pointHeight} | ${bitrate}kbps`;

            let latencyClass = 'latency-low';
            let latencyText = 'Ultra Low';
            let qualityText = 'Excellent';

            // Determine quality based on FPS and bitrate
            if (fps >= 55 && bitrate >= 3000) {
                qualityText = 'Ultra High';
                latencyClass = 'latency-low';
            } else if (fps >= 45 && bitrate >= 2000) {
                qualityText = 'High';
                latencyClass = 'latency-low';
            } else if (fps >= 30 && bitrate >= 1000) {
                qualityText = 'Good';
                latencyClass = 'latency-medium';
            } else {
                qualityText = 'Fair';
                latencyClass = 'latency-high';
                latencyText = 'Medium';
            }

            qualityInfo.textContent = `FPS: ${fps} | Quality: ${qualityText} | Dropped: ${dropped}`;
            latencyInfo.innerHTML = `<span class="latency-indicator ${latencyClass}"></span>Latency: ${latencyText}`;
        }

        function setWebRTCQuality(preset) {
            const presets = {
                'low': { fps: 30, bitrate: 1500000 },      // 1.5 Mbps, 30fps
                'medium': { fps: 45, bitrate: 3000000 },   // 3 Mbps, 45fps  
                'high': { fps: 60, bitrate: 5000000 },     // 5 Mbps, 60fps
                'ultra': { fps: 60, bitrate: 8000000 }     // 8 Mbps, 60fps
            };

            if (presets[preset]) {
                webrtcQualitySettings = presets[preset];
                currentWebRTCQuality = preset;

                // Update button highlighting
                updateWebRTCQualityButtonHighlight(preset);

                // Apply immediately if connected
                if (peerConnection && peerConnection.connectionState === 'connected') {
                    optimizeWebRTCQuality();
                }

                showTemporaryStatus(`WebRTC quality set to ${preset.toUpperCase()}`);
            }
        }

        function updateWebRTCQualityButtonHighlight(selectedQuality) {
            // Remove active class from all WebRTC quality buttons
            const webrtcQualitySection = document.getElementById('webrtc-quality-section');
            const qualityButtons = webrtcQualitySection.querySelectorAll('button');

            qualityButtons.forEach(button => {
                button.classList.remove('active');
            });

            // Add active class to selected quality button based on text content
            qualityButtons.forEach(button => {
                const buttonText = button.textContent.toLowerCase();
                if (buttonText.includes(selectedQuality)) {
                    button.classList.add('active');
                }
            });
        }



        // Handle window resize to maintain aspect ratio
        window.addEventListener('resize', () => {
            if (currentMode === 'webrtc' && webrtcVideo.videoWidth > 0) {
                resizeWebRTCVideo();
            } else if (currentMode === 'video' && pixelWidth > 0) {
                // Trigger a resize recalculation
                setTimeout(() => {
                    const img = new Image();
                    img.onload = () => {
                        const containerWidth = canvas.parentElement.clientWidth - 24;
                        const devicePixelRatio = window.devicePixelRatio || 1;
                        const aspectRatio = pixelWidth / pixelHeight;

                        let displayWidth = Math.min(containerWidth, 450);
                        let displayHeight = displayWidth / aspectRatio;

                        const maxHeight = window.innerHeight * 0.7;
                        if (displayHeight > maxHeight) {
                            displayHeight = maxHeight;
                            displayWidth = displayHeight * aspectRatio;
                        }

                        displayWidth = Math.round(displayWidth);
                        displayHeight = Math.round(displayHeight);

                        canvas.width = displayWidth * devicePixelRatio;
                        canvas.height = displayHeight * devicePixelRatio;
                        canvas.style.width = displayWidth + 'px';
                        canvas.style.height = displayHeight + 'px';

                        ctx.scale(devicePixelRatio, devicePixelRatio);
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.clearRect(0, 0, displayWidth, displayHeight);
                        ctx.drawImage(img, 0, 0, displayWidth, displayHeight);

                        dimensionInfo.textContent = `Pixels: ${pixelWidth}√ó${pixelHeight} | Points: ${pointWidth}√ó${pointHeight} | Display: ${displayWidth}√ó${displayHeight}`;
                    };
                    img.src = canvas.toDataURL();
                }, 100);
            }
        });
    </script>
</body>

</html>