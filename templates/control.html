<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>iOS Simulator Control - Session {{ session_id[:8] }}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
            overflow-x: auto;
        }

        .main-container {
            display: flex;
            gap: 20px;
            min-height: 100vh;
            align-items: flex-start;
        }

        .simulator-section {
            flex-shrink: 0;
            min-width: 400px;
            max-width: 500px;
        }

        .controls-panel {
            flex: 1;
            min-width: 400px;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #container {
            position: relative;
            display: inline-block;
            background: white;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 100%;
            box-sizing: border-box;
        }

        #screen,
        #webrtc-video {
            border: 2px solid #888;
            cursor: crosshair;
            background: #f0f0f0;
            border-radius: 8px;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: optimize-contrast;
            image-rendering: crisp-edges;
            width: 100%;
            height: auto;
            max-width: 100%;
            display: block;
            object-fit: contain;
        }

        #webrtc-video {
            max-height: 70vh;
            aspect-ratio: auto;
        }

        #status {
            margin: 10px 0;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            word-wrap: break-word;
            line-height: 1.3;
        }

        .connected {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .disconnected {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .controls-section {
            margin: 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .controls-section h3 {
            margin: 0 0 12px 0;
            color: #333;
            font-size: 16px;
            border-bottom: 2px solid #007bff;
            padding-bottom: 5px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
        }

        .controls-grid-wide {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
        }

        button {
            margin: 0;
            padding: 10px 12px;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-size: 13px;
            transition: background-color 0.2s;
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
        }

        button:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        button:active {
            background-color: #004085;
            transform: translateY(0);
        }

        .mode-toggle button {
            background-color: #28a745;
        }

        .mode-toggle button:hover {
            background-color: #1e7e34;
        }

        .mode-toggle button.active {
            background-color: #007bff !important;
            color: white !important;
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.5);
            transform: none !important;
        }

        .mode-toggle button.active:hover {
            background-color: #0056b3 !important;
        }

        .hardware-buttons button {
            background-color: #6c757d;
        }

        .hardware-buttons button:hover {
            background-color: #545b62;
        }

        .gesture-buttons button {
            background-color: #17a2b8;
        }

        .gesture-buttons button:hover {
            background-color: #117a8b;
        }

        .text-input-section {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .text-input-section input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            flex: 1;
            min-width: 200px;
            font-size: 14px;
        }

        .text-input-section button {
            flex-shrink: 0;
        }

        .swipe-mode {
            background-color: #ffc107 !important;
            color: #000 !important;
        }

        .swipe-mode:hover {
            background-color: #e0a800 !important;
        }

        .system-controls .controls-grid {
            grid-template-columns: repeat(2, 1fr);
        }

        #webrtc-quality-section {
            display: none;
        }

        #webrtc-quality-section.visible {
            display: block;
        }

        /* App Management Styles */
        .app-upload-section {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .app-upload-section input[type="file"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            flex: 1;
            min-width: 200px;
            font-size: 13px;
        }

        .app-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f8f9fa;
        }

        .app-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .app-item:last-child {
            border-bottom: none;
        }

        .app-info {
            flex: 1;
            min-width: 0;
        }

        .app-name {
            font-weight: bold;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .app-bundle {
            font-size: 11px;
            color: #666;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .app-actions {
            display: flex;
            gap: 5px;
            flex-shrink: 0;
        }

        .app-actions button {
            padding: 5px 8px;
            font-size: 11px;
            min-width: auto;
        }

        .btn-app-launch {
            background-color: #28a745;
        }

        .btn-app-launch:hover {
            background-color: #218838;
        }

        .btn-app-stop {
            background-color: #ffc107;
            color: #000;
        }

        .btn-app-stop:hover {
            background-color: #e0a800;
        }

        .btn-app-uninstall {
            background-color: #dc3545;
        }

        .btn-app-uninstall:hover {
            background-color: #c82333;
        }

        .no-apps {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }

        .app-count {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
                align-items: center;
            }

            .simulator-section {
                max-width: 100%;
                width: 100%;
            }

            .controls-panel {
                max-width: 100%;
                width: 100%;
            }
        }

        @media (max-width: 768px) {
            body {
                margin: 10px;
            }

            .controls-grid {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            }

            .controls-grid-wide {
                grid-template-columns: 1fr;
            }

            button {
                font-size: 12px;
                padding: 8px 10px;
            }

            .app-actions {
                flex-direction: column;
                gap: 3px;
            }
        }

        .title-section {
            grid-column: 1 / -1;
            text-align: center;
            margin-bottom: 10px;
        }

        .title-section h1 {
            margin: 0;
            color: #333;
            font-size: 24px;
        }

        .simulator-info {
            font-size: 11px;
            color: #666;
            text-align: center;
            margin-top: 10px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .webrtc-mode {
            background-color: #ff6b35 !important;
            color: white !important;
        }

        .webrtc-mode:hover {
            background-color: #e55a2b !important;
        }

        .stream-quality {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
            text-align: center;
        }

        .latency-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .latency-low {
            background-color: #28a745;
        }

        .latency-medium {
            background-color: #ffc107;
        }

        .latency-high {
            background-color: #dc3545;
        }

        .btn-install-launch {
            background-color: #28a745 !important;
            background: linear-gradient(135deg, #28a745, #20c997) !important;
            border: none;
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
        }

        .btn-install-launch:hover {
            background: linear-gradient(135deg, #218838, #1ba085) !important;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(40, 167, 69, 0.4);
        }

        .url-input-section {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .url-input-section input {
            min-width: 250px;
        }

        .url-example-btn {
            background-color: #e9ecef;
            color: #495057;
            border: 1px solid #ced4da;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 3px;
            font-size: 11px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .url-example-btn:hover {
            background-color: #dee2e6;
            color: #212529;
        }

        /* Mobile responsiveness for URL section */
        @media (max-width: 768px) {
            .url-input-section {
                flex-direction: column;
                align-items: stretch;
            }

            .url-input-section input {
                min-width: auto;
                width: 100%;
                margin-bottom: 5px;
            }

            .url-example-btn {
                font-size: 10px;
                padding: 3px 6px;
            }
        }

        /* Add these styles to your existing CSS */
        .section-toggle-icon {
            float: right;
            font-size: 14px;
            transition: transform 0.3s ease;
            user-select: none;
        }

        .section-toggle-icon.collapsed {
            transform: rotate(-90deg);
        }

        .apps-list-section {
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            overflow: hidden;
            max-height: 400px;
            /* Default expanded height */
            opacity: 1;
        }

        .apps-list-section.collapsed {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
        }

        /* Enhance app list for better collapsing */
        .app-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f8f9fa;
            transition: all 0.3s ease;
        }

        .apps-list-section.collapsed .app-list {
            max-height: 0;
            border: none;
            padding: 0;
        }

        /* Add a subtle animation for the count */
        .app-count {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .apps-list-section.collapsed .app-count {
            margin: 0;
            opacity: 0;
        }

        .device-controls h4 {
            margin: 0 0 12px 0;
            color: #333;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
        }

        .device-controls-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .device-control-btn {
            padding: 12px 8px;
            border: none;
            border-radius: 8px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            color: #495057;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-height: 60px;
            justify-content: center;
        }

        .device-control-btn:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
            transform: translateY(-1px);
        }

        .device-control-btn:active {
            transform: translateY(0);
            background-color: #dee2e6;
        }

        .device-control-btn .icon {
            font-size: 18px;
            margin-bottom: 2px;
        }

        .device-control-btn .label {
            font-size: 10px;
            font-weight: 500;
            text-align: center;
            line-height: 1.2;
        }

        /* Special styling for orientation button when in landscape */
        .device-control-btn.landscape {
            background-color: #fff3cd;
            border-color: #ffeaa7;
            color: #856404;
        }

        .device-control-btn.landscape:hover {
            background-color: #ffeaa7;
            border-color: #ffdd57;
        }

        @media (max-width: 768px) {
            #container {
                border-radius: 25px;
                padding: 15px;
            }

            #container::before {
                width: 100px;
                height: 20px;
                border-radius: 10px;
                top: 20px;
            }

            .device-controls-grid {
                gap: 8px;
            }

            .device-control-btn {
                padding: 10px 6px;
                min-height: 50px;
            }

            .device-control-btn .icon {
                font-size: 16px;
            }

            .device-control-btn .label {
                font-size: 9px;
            }
        }


        /* Log Viewer Styles */
        .logs-section {
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            overflow: hidden;
            max-height: 600px;
            opacity: 1;
        }

        .logs-section.collapsed {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
        }

        .log-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }

        .log-control-row {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .log-control-row select,
        .log-control-row input {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }

        .log-control-row select {
            min-width: 120px;
        }

        .log-container {
            height: 400px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #1e1e1e;
            color: #fff;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
            overflow: hidden;
            position: relative;
        }

        .log-content {
            height: 100%;
            overflow-y: auto;
            padding: 8px;
            line-height: 1.4;
        }

        .log-placeholder {
            text-align: center;
            color: #888;
            padding: 50px 20px;
            font-style: italic;
        }

        .log-entry {
            margin-bottom: 2px;
            padding: 2px 4px;
            border-radius: 2px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .log-entry.error {
            background-color: rgba(220, 53, 69, 0.1);
            border-left: 3px solid #dc3545;
            color: #ff6b6b;
        }

        .log-entry.warning {
            background-color: rgba(255, 193, 7, 0.1);
            border-left: 3px solid #ffc107;
            color: #ffeb3b;
        }

        .log-entry.debug {
            background-color: rgba(108, 117, 125, 0.1);
            border-left: 3px solid #6c757d;
            color: #adb5bd;
        }

        .log-entry.info {
            background-color: rgba(0, 123, 255, 0.05);
            border-left: 3px solid #007bff;
            color: #e0e0e0;
        }

        .log-timestamp {
            color: #6c757d;
            font-size: 10px;
        }

        .log-process {
            color: #28a745;
            font-weight: bold;
        }

        .log-message {
            margin-left: 8px;
        }

        .log-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            font-size: 10px;
            color: #666;
        }

        .btn-secondary {
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        .btn-secondary:hover {
            background-color: #5a6268;
        }

        .streaming {
            background-color: #28a745 !important;
        }

        .streaming:hover {
            background-color: #218838 !important;
        }

        @media (max-width: 768px) {
            .log-control-row {
                flex-direction: column;
                align-items: stretch;
            }

            .log-control-row select,
            .log-control-row input {
                width: 100%;
                margin-bottom: 4px;
            }

            .log-container {
                height: 300px;
            }

            /* Add these styles to your existing CSS in control.html */

            /* Location Controls Styles */
            .location-section {
                transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
                overflow: hidden;
                max-height: 500px;
                opacity: 1;
            }

            .location-section.collapsed {
                max-height: 0;
                opacity: 0;
                margin: 0;
                padding: 0;
            }

            .current-location {
                background: #f8f9fa;
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 10px;
                margin-bottom: 15px;
            }

            .location-status {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .location-controls {
                margin-bottom: 15px;
            }

            .location-input-row {
                display: flex;
                gap: 10px;
                align-items: end;
                flex-wrap: wrap;
            }

            .coordinate-input {
                display: flex;
                flex-direction: column;
                min-width: 120px;
            }

            .coordinate-input label {
                font-size: 11px;
                margin-bottom: 3px;
                font-weight: bold;
            }

            .coordinate-input input {
                padding: 8px;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 12px;
            }

            .location-presets h4 {
                margin: 0 0 10px 0;
                font-size: 13px;
                color: #666;
            }


            @media (max-width: 768px) {
                .location-input-row {
                    flex-direction: column;
                    align-items: stretch;
                }

                .coordinate-input {
                    min-width: auto;
                }

            }

            /* Add to your existing CSS in control.html */

            .predefined-locations {
                margin-top: 15px;
            }

            .predefined-locations h4 {
                margin: 0 0 10px 0;
                font-size: 13px;
                color: #666;
            }

            .predefined-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 8px;
                max-height: 150px;
                overflow-y: auto;
            }

            .predefined-btn {
                background: #e3f2fd;
                border: 1px solid #90caf9;
            }

            .predefined-btn:hover {
                background: #bbdefb;
                border-color: #64b5f6;
            }

            /* Add these updated styles to your control.html CSS section */

            /* Location Controls Styles - Simplified */
            .location-section {
                transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
                overflow: hidden;
                max-height: 600px;
                opacity: 1;
            }

            .location-section.collapsed {
                max-height: 0;
                opacity: 0;
                margin: 0;
                padding: 0;
            }

            .current-location {
                background: #f8f9fa;
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 10px;
                margin-bottom: 15px;
            }

            .location-status {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .location-controls {
                margin-bottom: 15px;
            }

            .location-input-row {
                display: flex;
                gap: 10px;
                align-items: end;
                flex-wrap: wrap;
                margin-bottom: 10px;
            }

            .coordinate-input {
                display: flex;
                flex-direction: column;
                min-width: 120px;
            }

            .coordinate-input label {
                font-size: 11px;
                margin-bottom: 3px;
                font-weight: bold;
            }

            .coordinate-input input {
                padding: 8px;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 12px;
            }

            .coordinate-input input:not(:placeholder-shown) {
                background-color: #e8f5e8;
                border-color: #28a745;
            }

            .coordinate-input input:focus {
                border-color: #007bff;
                box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
            }

            .location-name-display {
                padding: 8px;
                background: #e8f5e8;
                border: 1px solid #c3e6c3;
                border-radius: 4px;
                font-size: 12px;
                color: #2d5a2d;
                margin-top: 8px;
            }

            .predefined-locations h4 {
                margin: 0 0 10px 0;
                font-size: 13px;
                color: #666;
                user-select: none;
            }

            /* Add/update these styles in your CSS section */

            .predefined-locations-list {
                max-height: 300px;
                overflow-y: auto;
                border: 1px solid #ddd;
                border-radius: 4px;
                background: #f8f9fa;
                transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
                opacity: 1;
                padding: 0;
            }

            .predefined-locations-list.collapsed {
                max-height: 0 !important;
                opacity: 0 !important;
                border: none !important;
                overflow: hidden !important;
                padding: 0 !important;
            }

            .predefined-item {
                padding: 8px 12px;
                border-bottom: 1px solid #eee;
                cursor: pointer;
                display: flex;
                justify-content: space-between;
                align-items: center;
                transition: background 0.2s;
            }

            .predefined-item:last-child {
                border-bottom: none;
            }

            .predefined-item:hover {
                background: #e9ecef;
            }

            .predefined-name {
                font-weight: bold;
                font-size: 12px;
                color: #333;
            }

            .predefined-coords {
                font-size: 10px;
                color: #666;
                font-family: monospace;
            }

            .predefined-loading {
                text-align: center;
                color: #666;
                font-style: italic;
                padding: 20px;
                font-size: 12px;
            }

            /* Enhanced toggle icon animation */
            .predefined-toggle-icon {
                float: right;
                font-size: 12px;
                transition: transform 0.3s ease;
                display: inline-block;
            }

            .predefined-toggle-icon.collapsed {
                transform: rotate(-90deg);
            }

            @media (max-width: 768px) {
                .location-input-row {
                    flex-direction: column;
                    align-items: stretch;
                }

                .coordinate-input {
                    min-width: auto;
                }
            }

            .predefined-item.selected {
                background: #28a745 !important;
                color: white !important;
                transform: scale(1.02);
            }

            .predefined-item:active {
                transform: scale(0.98);
            }

            /* Add a subtle animation */
            .predefined-item {
                transition: all 0.2s ease;
            }

            .media-drop-zone {
                border: 2px dashed #ddd;
                border-radius: 8px;
                padding: 40px;
                text-align: center;
                margin-bottom: 20px;
                transition: all 0.3s ease;
                cursor: pointer;
            }

            .media-drop-zone.drag-highlight {
                border-color: #007bff;
                background-color: #f0f8ff;
            }

            .drop-zone-content {
                pointer-events: none;
            }

            .drop-zone-icon {
                font-size: 48px;
                margin-bottom: 10px;
            }

            .drop-zone-text strong {
                font-size: 16px;
                color: #333;
            }

            .drop-zone-text small {
                color: #666;
                font-size: 12px;
            }

            .media-group {
                margin-bottom: 20px;
                padding: 15px;
                border: 1px solid #eee;
                border-radius: 6px;
                background: #fafafa;
            }

            .media-group h4 {
                margin: 0 0 10px 0;
                font-size: 14px;
                color: #333;
            }

            .media-btn {
                background: #007bff;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
                margin: 2px;
                transition: background 0.2s;
            }

            .media-btn:hover {
                background: #0056b3;
            }

            .photo-btn {
                background: #28a745;
            }

            .photo-btn:hover {
                background: #1e7e34;
            }

            .video-btn {
                background: #dc3545;
            }

            .video-btn:hover {
                background: #c82333;
            }

            .push-btn {
                background: #ffc107;
                color: #000;
            }

            .push-btn:hover {
                background: #e0a800;
            }

            .pull-btn {
                background: #17a2b8;
            }

            .pull-btn:hover {
                background: #138496;
            }

            .file-transfer-controls {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                align-items: center;
                margin-bottom: 5px;
            }

            .path-input,
            .bundle-input,
            .filename-input {
                flex: 1;
                min-width: 200px;
                padding: 6px 10px;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 12px;
            }

            .quick-actions {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
            }

            .quick-btn {
                background: #6c757d;
                color: white;
                border: none;
                padding: 6px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 11px;
                transition: background 0.2s;
            }

            .quick-btn:hover {
                background: #5a6268;
            }

            .media-group small {
                color: #666;
                font-size: 11px;
                display: block;
                margin-top: 5px;
            }


        }
    </style>
    <script src="/static/js/logs.js" onerror="console.error('Failed to load logs.js')"></script>
    <script src="/static/js/location.js" onerror="console.error('Failed to load location.js')"></script>
    <script src="/static/js/media_transfer.js" onerror="console.error('Failed to load media_transfer.js')"></script>

</head>

<body>
    <div class="title-section">
        <h1>🎮 iOS Simulator Control - {{ session_info.device_type }} (iOS {{ session_info.ios_version }})</h1>
        <p>Session: {{ session_id[:8] }} | UDID: {{ session_info.udid[:8] }}</p>
        <a href="/web" style="color: #007bff; text-decoration: none;">← Back to Sessions</a>
    </div>

    <div class="main-container">
        <!-- Simulator Section -->
        <div class="simulator-section">
            <div id="status" class="disconnected">Connecting...</div>

            <div id="container">
                <div class="screen-container">
                    <canvas id="screen" width="400" height="600"></canvas>
                    <video id="webrtc-video" style="display: none;" autoplay playsinline muted></video>
                </div>

                <div class="simulator-info">
                    <div id="dimensionInfo">Loading simulator dimensions...</div>
                    <div class="stream-quality">
                        <div id="qualityInfo"></div>
                        <div id="latencyInfo"></div>
                    </div>
                </div>
            </div>

            <!-- Device Controls Section -->
            <div class="device-controls">
                <h4>📱 Device Controls</h4>
                <div class="device-controls-grid">
                    <button class="device-control-btn" onclick="takeDeviceScreenshot()" id="screenshotBtn">
                        <span class="icon">📸</span>
                        <span class="label">Screenshot</span>
                    </button>

                    <button class="device-control-btn" onclick="pressHomeButton()" id="homeBtn">
                        <span class="icon">🏠</span>
                        <span class="label">Home Button</span>
                    </button>

                    <button class="device-control-btn" onclick="toggleOrientation()" id="orientationBtn">
                        <span class="icon">🔄</span>
                        <span class="label">Portrait</span>
                    </button>
                </div>
            </div>
        </div>
        <!-- Controls Panel -->
        <div class="controls-panel">
            <div class="controls-section">
                <h3>📱 Stream Mode</h3>
                <div class="mode-toggle controls-grid">
                    <button id="webrtc-btn" onclick="switchMode('webrtc')">🚀 WebRTC Stream</button>
                    <button id="video-btn" onclick="switchMode('video')" class="active">🎥 WebSocket Stream</button>
                    <button id="screenshot-btn" onclick="switchMode('screenshot')">📷 Screenshot Mode</button>
                </div>
            </div>

            <!-- WebRTC Quality Section -->
            <div id="webrtc-quality-section" class="controls-section">
                <h3>🎬 WebRTC Quality</h3>
                <div class="mode-toggle controls-grid">
                    <button id="quality-medium-btn" onclick="setWebRTCQuality('medium')">📺 Medium</button>
                    <button id="quality-high-btn" onclick="setWebRTCQuality('high')" class="active">🏆 High</button>
                    <button id="quality-ultra-btn" onclick="setWebRTCQuality('ultra')">💎 Ultra</button>
                </div>
                <div style="font-size: 11px; color: #666; margin-top: 8px; text-align: center;">
                    Medium: 45fps/3Mbps | High: 60fps/5Mbps | Ultra: 60fps/8Mbps
                </div>
            </div>

            <!-- App Management Section -->
            <div class="controls-section">
                <h3 onclick="toggleAppsSection()" style="cursor: pointer;">
                    📱 App Management
                    <span id="appsToggleIcon" class="section-toggle-icon">▼</span>
                </h3>

                <div class="app-upload-section">
                    <input type="file" id="ipaFile" accept=".ipa" placeholder="Select IPA file..."
                        style="display: none;">
                    <input type="file" id="appBundle" accept=".zip" placeholder="Select APP bundle ZIP..."
                        style="display: none;">
                    <button onclick="selectAppType('ipa')" class="btn-app-launch">📱 Select IPA</button>
                    <button onclick="selectAppType('zip')" class="btn-app-launch">📦 Select APP Bundle ZIP</button>

                    <div class="install-options" style="position: relative; display: inline-block;">
                        <button onclick="toggleInstallOptions()" class="btn-app-launch">🚀 Install Options ▼</button>
                        <div id="installDropdown" class="install-dropdown"
                            style="display: none; position: absolute; background: white; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); z-index: 1000; min-width: 160px; top: 100%;">
                            <button onclick="installApp(); hideInstallOptions();"
                                style="width: 100%; text-align: left; border: none; background: none; padding: 8px 12px; cursor: pointer;">🚀
                                Install Only</button>
                            <button onclick="installAndLaunchApp(); hideInstallOptions();"
                                style="width: 100%; text-align: left; border: none; background: none; padding: 8px 12px; cursor: pointer; border-top: 1px solid #eee;">🚀▶️
                                Install & Launch</button>
                        </div>
                    </div>

                    <button onclick="refreshApps()" class="btn-primary">🔄 Refresh</button>
                    <div id="selectedFileName" style="font-size: 12px; color: #666; margin-top: 5px;"></div>
                    <div style="font-size: 11px; color: #999; margin-top: 3px;">
                        For APP bundles: First zip your .app bundle, then select the ZIP file
                    </div>
                </div>

                <!-- Collapsible App List Section -->
                <div id="appsListSection" class="apps-list-section">
                    <div class="app-count" id="appCount">Loading apps...</div>
                    <div class="app-list" id="appList">
                        <div class="no-apps">Loading installed apps...</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-header">
                    <h3>📱 Media & File Transfer</h3>
                    <button onclick="toggleSection('mediaTransferSection')" class="toggle-btn">▼</button>
                </div>
                <div id="mediaTransferSection" class="section-content">

                    <!-- Drop Zone -->
                    <div id="mediaDropZone" class="media-drop-zone">
                        <div class="drop-zone-content">
                            <div class="drop-zone-icon">📁</div>
                            <div class="drop-zone-text">
                                <strong>Drop files here</strong><br>
                                <small>Photos, videos, or any files</small>
                            </div>
                        </div>
                    </div>

                    <!-- Photo Upload -->
                    <div class="media-group">
                        <h4>📷 Photos</h4>
                        <div class="input-group">
                            <input type="file" id="photoUpload" accept="image/*" multiple style="display: none;">
                            <button onclick="document.getElementById('photoUpload').click()"
                                class="media-btn photo-btn">
                                📷 Select Photos
                            </button>
                            <small>Supported: JPG, PNG, HEIC, GIF</small>
                        </div>
                    </div>

                    <!-- Video Upload -->
                    <div class="media-group">
                        <h4>🎥 Videos</h4>
                        <div class="input-group">
                            <input type="file" id="videoUpload" accept="video/*" multiple style="display: none;">
                            <button onclick="document.getElementById('videoUpload').click()"
                                class="media-btn video-btn">
                                🎥 Select Videos
                            </button>
                            <small>Supported: MP4, MOV, M4V</small>
                        </div>
                    </div>

                    <!-- File Push -->
                    <div class="media-group">
                        <h4>📤 Push File to Simulator</h4>
                        <div class="file-transfer-controls">
                            <input type="file" id="pushFileInput" style="display: none;">
                            <button onclick="document.getElementById('pushFileInput').click()" class="media-btn">
                                📁 Select File
                            </button>
                            <input type="text" id="devicePathInput"
                                placeholder="Device path (e.g., /Documents/myfile.txt)" class="path-input">
                            <input type="text" id="bundleIdInput" placeholder="Bundle ID (optional)"
                                class="bundle-input">
                            <button id="pushFileBtn" class="media-btn push-btn">📤 Push File</button>
                        </div>
                        <small>Push any file to simulator filesystem or app container</small>
                    </div>

                    <!-- File Pull -->
                    <div class="media-group">
                        <h4>📥 Pull File from Simulator</h4>
                        <div class="file-transfer-controls">
                            <input type="text" id="pullDevicePathInput"
                                placeholder="Device path (e.g., /Documents/myfile.txt)" class="path-input">
                            <input type="text" id="pullBundleIdInput" placeholder="Bundle ID (optional)"
                                class="bundle-input">
                            <input type="text" id="pullFilenameInput" placeholder="Save as filename (optional)"
                                class="filename-input">
                            <button id="pullFileBtn" class="media-btn pull-btn">📥 Pull File</button>
                        </div>
                        <small>Pull any file from simulator to download</small>
                    </div>

                    <!-- Quick Actions -->
                    <div class="media-group">
                        <h4>⚡ Quick Actions</h4>
                        <div class="quick-actions">
                            <button onclick="fillCommonPath('/Documents/')" class="quick-btn">📄 Documents</button>
                            <button onclick="fillCommonPath('/Library/')" class="quick-btn">📚 Library</button>
                            <button onclick="fillCommonPath('/tmp/')" class="quick-btn">🗂️ Temp</button>
                            <button onclick="getAppContainer()" class="quick-btn">📱 App Container</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="controls-section">
                <h3>🌐 URL & Deep Links</h3>

                <div class="url-input-section">
                    <input type="text" id="urlInput" placeholder="Enter URL or deep link..."
                        style="flex: 1; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                    <button onclick="openUrl()" class="btn-app-launch" style="flex-shrink: 0;">🌐 Open URL</button>
                    <button onclick="showUrlExamples()" class="btn-primary" style="flex-shrink: 0;">💡 Examples</button>
                </div>

                <div id="urlExamples"
                    style="display: none; margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 12px;">
                    <strong>Examples:</strong><br>
                    <div style="margin: 5px 0;">
                        <button onclick="fillUrlExample('https://www.apple.com')" class="url-example-btn">🌐 Apple
                            Website</button>
                        <button onclick="fillUrlExample('https://www.google.com')" class="url-example-btn">🔍
                            Google</button>
                        <button onclick="fillUrlExample('mailto:test@example.com')" class="url-example-btn">📧
                            Email</button>
                    </div>
                    <div style="margin: 5px 0;">
                        <button onclick="fillUrlExample('tel:+1234567890')" class="url-example-btn">📞 Phone</button>
                        <button onclick="fillUrlExample('sms:+1234567890')" class="url-example-btn">💬 SMS</button>
                        <button onclick="fillUrlExample('maps:?q=Apple Park')" class="url-example-btn">🗺️ Maps</button>
                    </div>
                    <div style="margin: 5px 0;">
                        <button onclick="fillUrlExample('settings:root=General')" class="url-example-btn">⚙️
                            Settings</button>
                        <button onclick="fillUrlExample('facetime:+1234567890')" class="url-example-btn">📹
                            FaceTime</button>
                        <button onclick="fillUrlExample('shortcuts:')" class="url-example-btn">⚡ Shortcuts</button>
                    </div>
                    <div style="font-size: 10px; color: #666; margin-top: 8px;">
                        💡 Tip: You can also open custom app URL schemes if the app supports them
                    </div>
                </div>
            </div>

            <div class="controls-section">
                <h3>⌨️ Text Input</h3>
                <div class="text-input-section">
                    <input type="text" id="textInput" placeholder="Enter text to type..." maxlength="200">
                    <button onclick="sendText()">📤 Send</button>
                    <button onclick="clearText()">🗑️ Clear</button>
                </div>
            </div>


            <div class="controls-section gesture-buttons">
                <h3>👆 Gesture Controls</h3>
                <div class="controls-grid-wide">
                    <button id="swipeToggle" onclick="toggleSwipeMode()">✋ Enable Swipe Mode</button>
                </div>

                <br>

                <div class="controls-grid">
                    <button onclick="quickSwipe('up')">⬆️ Up</button>
                    <button onclick="quickSwipe('down')">⬇️ Down</button>
                    <button onclick="quickSwipe('left')">⬅️ Left</button>
                    <button onclick="quickSwipe('right')">➡️ Right</button>
                </div>
            </div>

            <!-- Replace the existing location section with this simplified version -->

            <div class="controls-section">
                <h3 onclick="toggleLocationSection()" style="cursor: pointer;">
                    📍 Mock Location
                    <span id="locationToggleIcon" class="section-toggle-icon">▼</span>
                </h3>

                <div id="locationSection" class="location-section">
                    <!-- Current Location Display -->
                    <div class="current-location">
                        <div class="location-status" id="locationStatus">
                            <span id="currentLocationText">No location set</span>
                            <button onclick="clearLocation()" id="clearLocationBtn" class="btn-secondary"
                                style="display: none;">Clear</button>
                        </div>
                    </div>

                    <!-- Location Input -->
                    <div class="location-controls">
                        <div class="location-input-row">
                            <div class="coordinate-input">
                                <label for="latitudeInput">Latitude:</label>
                                <input type="number" id="latitudeInput" placeholder="37.7749" step="any" min="-90"
                                    max="90">
                            </div>
                            <div class="coordinate-input">
                                <label for="longitudeInput">Longitude:</label>
                                <input type="number" id="longitudeInput" placeholder="-122.4194" step="any" min="-180"
                                    max="180">
                            </div>
                            <button onclick="setCustomLocation()" class="btn-primary">📍 Set Location</button>
                            <button onclick="getCurrentCoordinates()" class="btn-secondary">📱 Current</button>
                        </div>

                        <!-- Location Name Display -->
                        <div id="locationNameDisplay" class="location-name-display" style="display: none;">
                            <span id="locationNameText"></span>
                        </div>
                    </div>

                    <!-- Predefined Locations (Collapsible) -->
                    <div class="predefined-locations">
                        <h4 onclick="togglePredefinedLocations()" style="cursor: pointer;">
                            🌍 Predefined Locations
                            <span id="predefinedToggleIcon" class="predefined-toggle-icon">▼</span>
                        </h4>
                        <div id="predefinedLocationsList" class="predefined-locations-list">
                            <div class="predefined-loading">Loading locations...</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="controls-section">
                <h3 onclick="toggleLogsSection()" style="cursor: pointer;">
                    📋 Device Logs
                    <span id="logsToggleIcon" class="section-toggle-icon">▼</span>
                </h3>

                <div id="logsSection" class="logs-section">
                    <!-- Log Controls -->
                    <div class="log-controls">
                        <div class="log-control-row">
                            <select id="logLevel" onchange="applyLogFilter()">
                                <option value="all">All Levels</option>
                                <option value="debug">Debug</option>
                                <option value="info">Info</option>
                                <option value="warning">Warning</option>
                                <option value="error">Error</option>
                            </select>

                            <select id="logProcess" onchange="applyLogFilter()">
                                <option value="">All Processes</option>
                            </select>

                            <button onclick="clearLogs()" class="btn-secondary">🗑️ Clear</button>
                            <button onclick="toggleLogStream()" id="logStreamBtn" class="btn-primary">▶️ Start
                                Stream</button>
                            <button onclick="exportLogs()" class="btn-secondary">💾 Export</button>
                        </div>

                        <div class="log-control-row">
                            <input type="text" id="logSearch" placeholder="Search logs..."
                                onkeyup="filterDisplayedLogs()" style="flex: 1;">
                            <button onclick="scrollToBottom()" class="btn-secondary">⬇️ Bottom</button>
                            <button onclick="toggleAutoScroll()" id="autoScrollBtn" class="btn-secondary">📌
                                Auto-scroll</button>
                        </div>
                    </div>

                    <!-- Log Display -->
                    <div id="logContainer" class="log-container">
                        <div id="logContent" class="log-content">
                            <div class="log-placeholder">
                                📋 Device logs will appear here<br>
                                <small>Click "Start Stream" to begin real-time logging</small>
                            </div>
                        </div>
                    </div>

                    <!-- Log Status -->
                    <div class="log-status" id="logStatus">
                        <span id="logCount">0 logs</span> |
                        <span id="logRate">0 logs/sec</span> |
                        <span id="connectionStatus">Disconnected</span>
                    </div>
                </div>
            </div>
            <div class="controls-section system-controls">
                <h3>🎮 System Controls</h3>
                <div class="controls-grid">
                    <button onclick="restartPipeline()">🔄 Restart</button>
                    <button onclick="checkStatus()">📊 Status</button>
                    <button onclick="takeScreenshot()">🔄 Refresh</button>
                    <button onclick="testTap()">🎯 Test Tap</button>
                </div>
            </div>

            <div class="controls-section hardware-buttons">
                <h3>🔘 Hardware Buttons</h3>
                <div class="controls-grid">
                    <button onclick="pressButton('home')">🏠 Home</button>
                    <button onclick="pressButton('lock')">🔒 Lock</button>
                    <button onclick="pressButton('siri')">🎤 Siri</button>
                    <button onclick="pressButton('side-button')">📱 Side</button>
                    <button onclick="pressButton('apple-pay')">💳 Pay</button>
                    <button onclick="pressVolumeButton('up')">🔊 Vol+</button>
                    <button onclick="pressVolumeButton('down')">🔉 Vol-</button>
                    <button onclick="pressShakeButton()">📳 Shake</button>
                </div>
            </div>



            <div class="controls-section">
                <h3>⌨️ Keyboard Shortcuts</h3>
                <div style="font-size: 11px; color: #666; line-height: 1.4;">
                    <strong>W</strong>=WebRTC, <strong>V</strong>=Video, <strong>C</strong>=Screenshot<br>
                    <strong>H</strong>=Home, <strong>L</strong>=Lock, <strong>S</strong>=Siri,
                    <strong>P</strong>=Pay<br>
                    <strong>+/-</strong>=Volume, <strong>K</strong>=Shake, <strong>Space</strong>=Toggle Swipe<br>
                    <strong>Arrow Keys</strong>=Quick Swipes, <strong>Enter</strong>=Send Text<br>
                    <strong>U</strong>=Focus URL Input, <strong>A</strong>=Toggle Apps List<br>
                    <strong>X</strong>=Screenshot, <strong>R</strong>=Rotate, <strong>Home</strong>=Home Button<br>
                    <strong>G</strong>=Toggle Logs, <strong>L</strong>=Toggle Location, <strong>Escape</strong>=Stop Log
                    Stream
                </div>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script>
        // Pass session_id to JavaScript
        const SESSION_ID = '{{ session_id }}';

        const canvas = document.getElementById('screen');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        const textInput = document.getElementById('textInput');
        const swipeToggle = document.getElementById('swipeToggle');
        const dimensionInfo = document.getElementById('dimensionInfo');
        const qualityInfo = document.getElementById('qualityInfo');
        const latencyInfo = document.getElementById('latencyInfo');
        const webrtcVideo = document.getElementById('webrtc-video');
        let currentWebRTCQuality = 'high';

        let currentMode = 'video';
        let videoWs = null;
        let screenshotWs = null;
        let controlWs = null;

        // WebRTC variables
        let webrtcWs = null;
        let peerConnection = null;
        let webrtcStats = {
            bytesReceived: 0,
            framesReceived: 0,
            lastStatsTime: 0,
            latency: 0,
            fps: 0
        };
        let webrtcQualitySettings = {
            fps: 60,
            resolution: 'high',
            bitrate: 5000000
        };

        // Gesture mode
        let swipeMode = false;
        let swipeStart = null;

        // Performance tracking
        let frameCount = 0;
        let lastFrameTime = 0;
        let fpsHistory = [];
        let performanceStats = {
            averageFps: 0,
            frameDrops: 0,
            lastUpdate: 0
        };

        // Coordinate systems
        let pixelWidth = 0, pixelHeight = 0;
        let pointWidth = 0, pointHeight = 0;

        // App management
        let installedApps = [];

        let currentOrientation = 'portrait'; // 'portrait' or 'landscape'
        let isCapturingScreenshot = false;

        window.deviceLogsManager = null;

        // Function to check if DeviceLogsManager is available and initialize it
        function checkAndInitializeLogsManager() {
            console.log('Checking DeviceLogsManager availability...');

            if (typeof DeviceLogsManager !== 'undefined') {
                console.log('✅ DeviceLogsManager found, initializing...');

                // Initialize the logs manager
                window.deviceLogsManager = new DeviceLogsManager(SESSION_ID);
                console.log('DeviceLogsManager created:', window.deviceLogsManager);

                window.deviceLogsManager.initialize().then(() => {
                    console.log('✅ DeviceLogsManager initialized successfully');
                }).catch(error => {
                    console.error('❌ Failed to initialize DeviceLogsManager:', error);
                    showTemporaryStatus('❌ Log viewer initialization failed');
                });

                return true;
            } else {
                console.log('❌ DeviceLogsManager not found');
                return false;
            }
        }

        async function takeDeviceScreenshot() {
            if (isCapturingScreenshot) return;

            const screenshotBtn = document.getElementById('screenshotBtn');
            const originalContent = screenshotBtn.innerHTML;

            try {
                isCapturingScreenshot = true;
                screenshotBtn.innerHTML = '<span class="icon">⏳</span><span class="label">Capturing...</span>';
                screenshotBtn.disabled = true;

                showTemporaryStatus('📸 Capturing screenshot...');

                // Generate filename with timestamp
                const timestamp = new Date().getTime();
                const filename = `screenshot_${SESSION_ID.substring(0, 8)}_${timestamp}.png`;

                // Create a form to submit the request
                const formData = new FormData();
                formData.append('filename', filename);

                // Make the request to download screenshot endpoint
                const response = await fetch(`/api/sessions/${SESSION_ID}/screenshot/download`, {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    // Get the blob from response
                    const blob = await response.blob();

                    // Create a download link
                    const downloadUrl = window.URL.createObjectURL(blob);
                    const downloadLink = document.createElement('a');
                    downloadLink.href = downloadUrl;
                    downloadLink.download = filename;

                    // Trigger the download
                    document.body.appendChild(downloadLink);
                    downloadLink.click();

                    // Clean up
                    document.body.removeChild(downloadLink);
                    window.URL.revokeObjectURL(downloadUrl);

                    showTemporaryStatus(`✅ Screenshot downloaded: ${filename}`);

                    // Flash effect
                    document.body.style.backgroundColor = 'white';
                    setTimeout(() => {
                        document.body.style.backgroundColor = '#f5f5f5';
                    }, 100);

                } else {
                    const errorData = await response.json();
                    showTemporaryStatus(`❌ Screenshot failed: ${errorData.detail || 'Unknown error'}`);
                }

            } catch (error) {
                console.error('Screenshot error:', error);
                showTemporaryStatus('❌ Screenshot failed: ' + error.message);
            } finally {
                isCapturingScreenshot = false;
                screenshotBtn.innerHTML = originalContent;
                screenshotBtn.disabled = false;
            }
        }

        function pressHomeButton() {
            const homeBtn = document.getElementById('homeBtn');

            // Visual feedback
            homeBtn.style.transform = 'scale(0.95)';
            setTimeout(() => {
                homeBtn.style.transform = 'scale(1)';
            }, 150);

            // Send home button press
            pressButton('home');
        }

        async function toggleOrientation() {
            const orientationBtn = document.getElementById('orientationBtn');
            const container = document.getElementById('container');

            try {
                showTemporaryStatus('🔄 Changing orientation...');

                // Toggle orientation
                const newOrientation = currentOrientation === 'portrait' ? 'landscape' : 'portrait';

                // Create FormData instead of JSON
                const formData = new FormData();
                formData.append('orientation', newOrientation);

                const response = await fetch(`/api/sessions/${SESSION_ID}/orientation`, {
                    method: 'POST',
                    body: formData  // Send as FormData, not JSON
                });

                const data = await response.json();

                if (data.success) {
                    currentOrientation = newOrientation;
                    updateOrientationUI();
                    showTemporaryStatus(`✅ Orientation changed to ${newOrientation}`);
                } else {
                    showTemporaryStatus(`❌ Orientation change failed: ${data.message || 'Unknown error'}`);
                }

            } catch (error) {
                console.error('Orientation change error:', error);
                showTemporaryStatus('❌ Orientation change failed: ' + error.message);
            }
        }

        function updateOrientationUI() {
            const orientationBtn = document.getElementById('orientationBtn');
            const container = document.getElementById('container');

            if (currentOrientation === 'landscape') {
                orientationBtn.innerHTML = '<span class="icon">📱</span><span class="label">Landscape</span>';
                orientationBtn.classList.add('landscape');
                container.style.transform = 'rotate(0deg)'; // You can add rotation animation if desired
            } else {
                orientationBtn.innerHTML = '<span class="icon">🔄</span><span class="label">Portrait</span>';
                orientationBtn.classList.remove('landscape');
                container.style.transform = 'rotate(0deg)';
            }
        }


        init();

        function init() {
            setupControlWebSocket();
            setupKeyboardShortcuts();
            switchMode('video');
            loadInstalledApps();
            loadAppsListState();
            // Initialize logs and location
            setTimeout(() => {
                initLogViewer();
                initLocationControls();
            }, 500);
        }

        // Function to initialize log viewer
        function initLogViewer() {
            console.log('initLogViewer called...');

            // Try to initialize immediately
            if (checkAndInitializeLogsManager()) {
                return;
            }

            // If not available, wait a bit and try again
            let retryCount = 0;
            const maxRetries = 10;

            const retryInit = () => {
                retryCount++;
                console.log(`Retry ${retryCount}/${maxRetries} to initialize logs manager`);

                if (checkAndInitializeLogsManager()) {
                    console.log('✅ Logs manager initialized after retry');
                    return;
                }

                if (retryCount < maxRetries) {
                    setTimeout(retryInit, 100);
                } else {
                    console.error('❌ Failed to initialize logs manager after all retries');
                    showTemporaryStatus('❌ Log viewer failed to load - check console');
                }
            };

            setTimeout(retryInit, 100);
        }

        function testWebSocketConnection() {
            console.log('Testing WebSocket connection to logs endpoint');
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/${SESSION_ID}/logs`;

            console.log('WebSocket URL:', wsUrl);

            const testWs = new WebSocket(wsUrl);

            testWs.onopen = () => {
                console.log('✅ WebSocket connection successful');
                testWs.close();
            };

            testWs.onerror = (error) => {
                console.error('❌ WebSocket connection failed:', error);
            };

            testWs.onclose = (event) => {
                console.log('WebSocket closed:', event.code, event.reason);
            };
        }


        // App Management Functions
        async function loadInstalledApps() {
            try {
                const response = await fetch(`/api/sessions/${SESSION_ID}/apps`);
                const data = await response.json();

                if (data.success) {
                    installedApps = data.apps;
                    renderAppList();
                } else {
                    document.getElementById('appCount').textContent = 'Failed to load apps';
                    document.getElementById('appList').innerHTML = '<div class="no-apps">Failed to load apps</div>';
                }
            } catch (error) {
                console.error('Failed to load apps:', error);
                document.getElementById('appCount').textContent = 'Error loading apps';
                document.getElementById('appList').innerHTML = '<div class="no-apps">Error loading apps</div>';
            }
        }

        function renderAppList() {
            const appCountElement = document.getElementById('appCount');
            const appListElement = document.getElementById('appList');

            appCountElement.textContent = `Installed Apps (${installedApps.length})`;

            if (installedApps.length === 0) {
                appListElement.innerHTML = '<div class="no-apps">No apps installed</div>';
                return;
            }

            appListElement.innerHTML = installedApps.map(app => `
                <div class="app-item">
                    <div class="app-info">
                        <div class="app-name" title="${app.app_name}">${app.app_name}</div>
                        <div class="app-bundle" title="${app.bundle_id}">${app.bundle_id}</div>
                    </div>
                    <div class="app-actions">
                        <button onclick="launchApp('${app.bundle_id}')" class="btn-app-launch" title="Launch App">
                            ▶️
                        </button>
                        <button onclick="terminateApp('${app.bundle_id}')" class="btn-app-stop" title="Stop App">
                            ⏹️
                        </button>
                        <button onclick="uninstallApp('${app.bundle_id}')" class="btn-app-uninstall" title="Uninstall App">
                            🗑️
                        </button>
                    </div>
                </div>
            `).join('');
        }

        // Add to your control.html JavaScript section
        let selectedFileType = 'ipa';
        function selectAppType(type) {
            selectedFileType = type;
            const ipaInput = document.getElementById('ipaFile');
            const appInput = document.getElementById('appBundle');
            const fileNameDiv = document.getElementById('selectedFileName');

            // Clear previous selection
            ipaInput.value = '';
            appInput.value = '';
            fileNameDiv.textContent = '';

            if (type === 'ipa') {
                // For IPA files - single file selection
                ipaInput.click();

                ipaInput.onchange = () => {
                    if (ipaInput.files.length > 0) {
                        fileNameDiv.textContent = `Selected: ${ipaInput.files[0].name}`;
                    }
                };
            } else if (type === 'zip') {
                // For ZIP files containing .app bundles
                appInput.click();

                appInput.onchange = () => {
                    if (appInput.files.length > 0) {
                        fileNameDiv.textContent = `Selected: ${appInput.files[0].name}`;
                    }
                };
            }
        }
        // Replace the installApp function around line 755
        async function installApp() {
            const ipaInput = document.getElementById('ipaFile');
            const appInput = document.getElementById('appBundle');

            let file, fileType;

            if (selectedFileType === 'ipa') {
                if (!ipaInput.files || ipaInput.files.length === 0) {
                    showTemporaryStatus('Please select an IPA file');
                    return;
                }
                file = ipaInput.files[0];
                fileType = 'ipa';
            } else if (selectedFileType === 'zip') {
                if (!appInput.files || appInput.files.length === 0) {
                    showTemporaryStatus('Please select a ZIP file');
                    return;
                }
                file = appInput.files[0];
                fileType = 'zip';
            } else {
                showTemporaryStatus('Please select a file');
                return;
            }

            const formData = new FormData();

            if (fileType === 'ipa') {
                formData.append('ipa_file', file);
            } else {
                formData.append('app_bundle', file); // ZIP file containing .app bundle
            }

            try {
                showTemporaryStatus(`Installing ${fileType.toUpperCase()} file...`);
                const response = await fetch(`/api/sessions/${SESSION_ID}/apps/install`, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (data.success) {
                    showTemporaryStatus('App installed successfully!');
                    // Clear file inputs
                    ipaInput.value = '';
                    appInput.value = '';
                    document.getElementById('selectedFileName').textContent = '';
                    loadInstalledApps();
                } else {
                    showTemporaryStatus('Failed to install app: ' + (data.message || data.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Failed to install app:', error);
                showTemporaryStatus('Failed to install app: ' + error.message);
            }
        }

        // Add this function after the existing installApp function
        async function installAndLaunchApp() {
            const ipaInput = document.getElementById('ipaFile');
            const appInput = document.getElementById('appBundle');

            let file, fileType;

            if (selectedFileType === 'ipa') {
                if (!ipaInput.files || ipaInput.files.length === 0) {
                    showTemporaryStatus('Please select an IPA file');
                    return;
                }
                file = ipaInput.files[0];
                fileType = 'ipa';
            } else if (selectedFileType === 'zip') {
                if (!appInput.files || appInput.files.length === 0) {
                    showTemporaryStatus('Please select a ZIP file');
                    return;
                }
                file = appInput.files[0];
                fileType = 'zip';
            } else {
                showTemporaryStatus('Please select a file');
                return;
            }

            const formData = new FormData();

            if (fileType === 'ipa') {
                formData.append('ipa_file', file);
            } else {
                formData.append('app_bundle', file);
            }

            try {
                showTemporaryStatus(`Installing and launching ${fileType.toUpperCase()} file...`);
                const response = await fetch(`/api/sessions/${SESSION_ID}/apps/install-and-launch`, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (data.success) {
                    showTemporaryStatus(`App installed and launched successfully! Bundle ID: ${data.bundle_id || 'Unknown'}`);
                    // Clear file inputs
                    ipaInput.value = '';
                    appInput.value = '';
                    document.getElementById('selectedFileName').textContent = '';
                    loadInstalledApps();
                } else {
                    showTemporaryStatus('Failed to install and launch app: ' + (data.message || data.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Failed to install and launch app:', error);
                showTemporaryStatus('Failed to install and launch app: ' + error.message);
            }
        }

        async function launchApp(bundleId) {
            try {
                showTemporaryStatus(`Launching ${bundleId}...`);
                const response = await fetch(`/api/sessions/${SESSION_ID}/apps/${bundleId}/launch`, {
                    method: 'POST'
                });

                const data = await response.json();
                showTemporaryStatus(data.success ? 'App launched successfully!' : 'Failed to launch app');
            } catch (error) {
                console.error('Failed to launch app:', error);
                showTemporaryStatus('Failed to launch app');
            }
        }

        function toggleInstallOptions() {
            const dropdown = document.getElementById('installDropdown');
            dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
        }

        function hideInstallOptions() {
            document.getElementById('installDropdown').style.display = 'none';
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function (event) {
            const dropdown = document.getElementById('installDropdown');
            const button = event.target.closest('.install-options');
            if (!button && dropdown.style.display === 'block') {
                dropdown.style.display = 'none';
            }
        });

        async function terminateApp(bundleId) {
            try {
                showTemporaryStatus(`Stopping ${bundleId}...`);
                const response = await fetch(`/api/sessions/${SESSION_ID}/apps/${bundleId}/terminate`, {
                    method: 'POST'
                });

                const data = await response.json();
                showTemporaryStatus(data.success ? 'App stopped successfully!' : 'Failed to stop app');
            } catch (error) {
                console.error('Failed to terminate app:', error);
                showTemporaryStatus('Failed to stop app');
            }
        }

        async function uninstallApp(bundleId) {
            if (!confirm(`Are you sure you want to uninstall ${bundleId}?`)) {
                return;
            }

            try {
                showTemporaryStatus(`Uninstalling ${bundleId}...`);
                const response = await fetch(`/api/sessions/${SESSION_ID}/apps/${bundleId}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    showTemporaryStatus('App uninstalled successfully!');
                    loadInstalledApps(); // Refresh app list
                } else {
                    showTemporaryStatus('Failed to uninstall app');
                }
            } catch (error) {
                console.error('Failed to uninstall app:', error);
                showTemporaryStatus('Failed to uninstall app');
            }
        }

        function refreshApps() {
            loadInstalledApps();
            showTemporaryStatus('Refreshing app list...');
        }


        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if (e.target !== textInput && e.target !== document.getElementById('urlInput') &&
                    e.target !== document.getElementById('logSearch') &&
                    e.target !== document.getElementById('latitudeInput') &&
                    e.target !== document.getElementById('longitudeInput')) {

                    // Let the logs manager handle its shortcuts first
                    if (window.deviceLogsManager && window.deviceLogsManager.handleKeyboardShortcut(e.key)) {
                        e.preventDefault();
                        return;
                    }
                }
                switch (e.key) {
                    case 'w': switchMode('webrtc'); break;
                    case 'v': switchMode('video'); break;
                    case 'c': switchMode('screenshot'); break;
                    case 'h': pressButton('home'); break;
                    case 'l': pressButton('lock'); break;
                    case 's': pressButton('siri'); break;
                    case 'p': pressButton('apple-pay'); break;
                    case '=': case '+': pressVolumeButton('up'); break;
                    case '-': case '_': pressVolumeButton('down'); break;
                    case 'k': pressShakeButton(); break;
                    case 'ArrowUp': e.preventDefault(); quickSwipe('up'); break;
                    case 'ArrowDown': e.preventDefault(); quickSwipe('down'); break;
                    case 'ArrowLeft': e.preventDefault(); quickSwipe('left'); break;
                    case 'ArrowRight': e.preventDefault(); quickSwipe('right'); break;
                    case ' ': e.preventDefault(); toggleSwipeMode(); break;

                    case 'x': e.preventDefault(); takeDeviceScreenshot(); break;
                    case 'Home': e.preventDefault(); pressHomeButton(); break;
                    case 'r': e.preventDefault(); toggleOrientation(); break;
                    case 'a': e.preventDefault(); toggleAppsSection(); break;
                    case 'l': // L for location
                        e.preventDefault();
                        toggleLocationSection();
                        break;
                }
            });

            // Handle text input with Enter key
            textInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendText();
                }
            });
        }

        window.addEventListener('beforeunload', () => {
            if (window.deviceLogsManager) {
                window.deviceLogsManager.cleanup();
            }
        });


        function setupControlWebSocket() {
            controlWs = new WebSocket(`ws://${location.hostname}:8000/ws/${SESSION_ID}/control`);

            controlWs.onopen = () => {
                console.log('Control WebSocket connected');
            };

            controlWs.onerror = (error) => {
                console.error('Control WebSocket error:', error);
                showTemporaryStatus('Control connection error');
            };

            controlWs.onclose = () => {
                console.log('Control WebSocket disconnected, reconnecting...');
                showTemporaryStatus('Control connection lost, reconnecting...');
                setTimeout(setupControlWebSocket, 2000);
            };
        }


        function switchMode(mode) {
            currentMode = mode;

            // Update button highlighting
            updateModeButtonHighlight(mode);

            // Show/hide WebRTC quality section
            const webrtcQualitySection = document.getElementById('webrtc-quality-section');
            if (mode === 'webrtc') {
                webrtcQualitySection.classList.add('visible');
                // Initialize WebRTC quality button highlighting
                updateWebRTCQualityButtonHighlight(currentWebRTCQuality);
            } else {
                webrtcQualitySection.classList.remove('visible');
            }

            // Clean up existing connections
            if (videoWs) videoWs.close();
            if (screenshotWs) screenshotWs.close();
            if (webrtcWs) webrtcWs.close();
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            // Hide/show appropriate elements
            canvas.style.display = mode === 'webrtc' ? 'none' : 'block';
            webrtcVideo.style.display = mode === 'webrtc' ? 'block' : 'none';

            if (mode === 'video') {
                setupHighPerformanceVideoStream();
            } else if (mode === 'screenshot') {
                setupScreenshotMode();
            } else if (mode === 'webrtc') {
                setupWebRTCStream();
            }
        }

        function updateModeButtonHighlight(currentMode) {
            // Remove active class from all mode buttons
            document.getElementById('webrtc-btn').classList.remove('active');
            document.getElementById('video-btn').classList.remove('active');
            document.getElementById('screenshot-btn').classList.remove('active');

            // Add active class to current mode button
            if (currentMode === 'webrtc') {
                document.getElementById('webrtc-btn').classList.add('active');
            } else if (currentMode === 'video') {
                document.getElementById('video-btn').classList.add('active');
            } else if (currentMode === 'screenshot') {
                document.getElementById('screenshot-btn').classList.add('active');
            }
        }

        function setupHighPerformanceVideoStream() {
            videoWs = new WebSocket(`ws://${location.hostname}:8000/ws/${SESSION_ID}/video`);

            videoWs.onopen = () => {
                console.log('Hardware-accelerated video WebSocket connected');
                status.textContent = 'Hardware video stream connecting...';
                status.className = 'connected';
                frameCount = 0;
                frameDropCount = 0;
                lastFrameTime = performance.now();
                isProcessingFrame = false;
            };

            videoWs.onclose = () => {
                status.textContent = 'Video stream disconnected';
                status.className = 'disconnected';
            };

            videoWs.onmessage = (event) => {
                // Drop frames if we're still processing
                if (isProcessingFrame) {
                    frameDropCount++;
                    return;
                }

                isProcessingFrame = true;

                try {
                    const now = performance.now();
                    const data = JSON.parse(event.data);

                    if (data.type === 'video_frame') {
                        frameCount++;

                        // Use requestAnimationFrame for smooth rendering
                        requestAnimationFrame(() => {
                            processVideoFrame(data, now);
                            isProcessingFrame = false;
                        });
                    }
                } catch (error) {
                    console.error('Frame processing error:', error);
                    isProcessingFrame = false;
                }
            };

            videoWs.onerror = (error) => {
                console.error('Video WebSocket error:', error);
                status.textContent = 'Video stream error';
                status.className = 'disconnected';
            };
        }

        function processVideoFrame(data, now) {
            const frameDelta = now - lastFrameTime;
            if (frameDelta > 0) {
                const instantFps = 1000 / frameDelta;
                fpsHistory.push(instantFps);
                if (fpsHistory.length > 20) fpsHistory.shift();

                performanceStats.averageFps = Math.round(
                    fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length
                );
            }
            lastFrameTime = now;

            const img = new Image();
            img.onload = () => {
                pixelWidth = data.pixel_width || data.width || img.width;
                pixelHeight = data.pixel_height || data.height || img.height;
                pointWidth = data.point_width || 390;
                pointHeight = data.point_height || 844;

                // Optimized canvas rendering
                updateCanvasOptimized(img, data);

                // Update status less frequently
                if (frameCount % 60 === 0 || now - performanceStats.lastUpdate > 2000) {
                    const serverFps = data.fps || 0;
                    const modeText = swipeMode ? '✋ SWIPE MODE' : '👆 TAP MODE';
                    const dropRate = frameDropCount > 0 ? ` (${frameDropCount} drops)` : '';
                    status.textContent = `🎥 ${modeText} | Frame: ${frameCount}, Client: ${performanceStats.averageFps}fps, Server: ${serverFps}fps${dropRate}`;
                    performanceStats.lastUpdate = now;
                    frameDropCount = 0; // Reset drop counter
                }
            };

            // Handle JPEG format
            img.src = `data:image/jpeg;base64,${data.data}`;
        }

        function updateCanvasOptimized(img, data) {
            // Calculate display size with better performance
            const screenContainer = document.querySelector('.screen-container');
            const containerWidth = screenContainer.clientWidth - 4; // Account for border
            const devicePixelRatio = Math.min(window.devicePixelRatio || 1, 2);
            const aspectRatio = pixelWidth / pixelHeight;

            let displayWidth = Math.min(containerWidth, 400);
            let displayHeight = displayWidth / aspectRatio;

            const maxHeight = window.innerHeight * 0.6;
            if (displayHeight > maxHeight) {
                displayHeight = maxHeight;
                displayWidth = displayHeight * aspectRatio;
            }

            displayWidth = Math.round(displayWidth);
            displayHeight = Math.round(displayHeight);

            // Only resize canvas if dimensions changed
            const newCanvasWidth = displayWidth * devicePixelRatio;
            const newCanvasHeight = displayHeight * devicePixelRatio;

            if (canvas.width !== newCanvasWidth || canvas.height !== newCanvasHeight) {
                canvas.width = newCanvasWidth;
                canvas.height = newCanvasHeight;
                canvas.style.width = displayWidth + 'px';
                canvas.style.height = displayHeight + 'px';

                ctx.scale(devicePixelRatio, devicePixelRatio);
            }

            // Optimized rendering
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.clearRect(0, 0, displayWidth, displayHeight);
            ctx.drawImage(img, 0, 0, displayWidth, displayHeight);

            // Update dimension info
            dimensionInfo.textContent = `Pixels: ${pixelWidth}×${pixelHeight} | Points: ${pointWidth}×${pointHeight} | Display: ${displayWidth}×${displayHeight} | JPEG`;
        }

        // Add frame rate monitoring
        setInterval(() => {
            if (frameCount > 0) {
                console.log(`Performance: ${performanceStats.averageFps}fps average, ${frameDropCount} dropped frames in last 5s`);
            }
        }, 5000);

        function setupScreenshotMode() {
            screenshotWs = new WebSocket(`ws://${location.hostname}:8000/ws/${SESSION_ID}/screenshot`);

            screenshotWs.onopen = () => {
                console.log('Screenshot WebSocket connected');
                status.textContent = 'High-quality screenshot mode connected';
                status.className = 'connected';
            };

            screenshotWs.onclose = () => {
                status.textContent = 'Screenshot mode disconnected';
                status.className = 'disconnected';
            };

            screenshotWs.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'screenshot') {
                    const img = new Image();
                    img.onload = () => {
                        pixelWidth = data.pixel_width || data.width || img.width;
                        pixelHeight = data.pixel_height || data.height || img.height;
                        pointWidth = data.point_width || 390;
                        pointHeight = data.point_height || 844;

                        updateCanvasOptimized(img, data);

                        const modeText = swipeMode ? '✋ SWIPE MODE' : '👆 TAP MODE';
                        status.textContent = `📷 ${modeText} | High-quality screenshot | JPEG format`;
                    };
                    img.src = `data:image/jpeg;base64,${data.data}`;
                }
            };
        }
        // Enhanced click/swipe handler (coordinate mapping preserved)
        canvas.onmousedown = (ev) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = ev.clientX - rect.left;
            const clickY = ev.clientY - rect.top;

            if (swipeMode) {
                swipeStart = { x: clickX, y: clickY };
                canvas.style.cursor = 'grab';
            } else {
                handleTap(clickX, clickY);
            }
        };

        canvas.onmouseup = (ev) => {
            if (swipeMode && swipeStart) {
                const rect = canvas.getBoundingClientRect();
                const endX = ev.clientX - rect.left;
                const endY = ev.clientY - rect.top;

                handleSwipe(swipeStart.x, swipeStart.y, endX, endY);
                swipeStart = null;
                canvas.style.cursor = 'crosshair';
            }
        };

        canvas.onmouseleave = () => {
            if (swipeMode) {
                swipeStart = null;
                canvas.style.cursor = 'crosshair';
            }
        };

        function handleTap(clickX, clickY) {
            if (pointWidth > 0 && pointHeight > 0) {
                const displayWidth = parseInt(canvas.style.width);
                const displayHeight = parseInt(canvas.style.height);

                const tapX = Math.round((clickX / displayWidth) * pointWidth);
                const tapY = Math.round((clickY / displayHeight) * pointHeight);

                console.log(`Tap: Display(${Math.round(clickX)}, ${Math.round(clickY)}) -> Point(${tapX}, ${tapY})`);

                if (currentMode === 'screenshot' && screenshotWs) {
                    screenshotWs.send(JSON.stringify({ t: 'tap', x: tapX, y: tapY }));
                } else if (currentMode === 'video' && controlWs) {
                    controlWs.send(JSON.stringify({ t: 'tap', x: tapX, y: tapY }));
                }

                showTemporaryStatus(`Tapped: (${tapX}, ${tapY})`);
            }
        }

        function handleSwipe(startX, startY, endX, endY) {
            if (pointWidth > 0 && pointHeight > 0) {
                const displayWidth = parseInt(canvas.style.width);
                const displayHeight = parseInt(canvas.style.height);

                const startPointX = Math.round((startX / displayWidth) * pointWidth);
                const startPointY = Math.round((startY / displayHeight) * pointHeight);
                const endPointX = Math.round((endX / displayWidth) * pointWidth);
                const endPointY = Math.round((endY / displayHeight) * pointHeight);

                console.log(`Swipe: Point(${startPointX}, ${startPointY}) -> Point(${endPointX}, ${endPointY})`);

                const swipeData = {
                    t: 'swipe',
                    start_x: startPointX,
                    start_y: startPointY,
                    end_x: endPointX,
                    end_y: endPointY,
                    duration: 0.3
                };

                if (currentMode === 'screenshot' && screenshotWs) {
                    screenshotWs.send(JSON.stringify(swipeData));
                } else if (currentMode === 'video' && controlWs) {
                    controlWs.send(JSON.stringify(swipeData));
                }

                showTemporaryStatus(`Swiped: (${startPointX}, ${startPointY}) → (${endPointX}, ${endPointY})`);
            }
        }

        function toggleSwipeMode() {
            swipeMode = !swipeMode;
            if (swipeMode) {
                swipeToggle.textContent = '👆 Disable Swipe Mode';
                swipeToggle.className = 'swipe-mode';

                // Update cursor for both canvas and video
                canvas.style.cursor = 'crosshair';
                webrtcVideo.style.cursor = 'crosshair';
            } else {
                swipeToggle.textContent = '✋ Enable Swipe Mode';
                swipeToggle.className = '';

                // Update cursor for both canvas and video
                canvas.style.cursor = 'crosshair';
                webrtcVideo.style.cursor = 'crosshair';
            }

            const modeText = swipeMode ? '✋ SWIPE MODE ENABLED' : '👆 TAP MODE ENABLED';
            showTemporaryStatus(modeText);
        }
        function quickSwipe(direction) {
            if (pointWidth === 0 || pointHeight === 0) return;

            const centerX = Math.round(pointWidth / 2);
            const centerY = Math.round(pointHeight / 2);
            const distance = 200;

            let startX, startY, endX, endY;

            switch (direction) {
                case 'up':
                    startX = centerX; startY = centerY + distance;
                    endX = centerX; endY = centerY - distance;
                    break;
                case 'down':
                    startX = centerX; startY = centerY - distance;
                    endX = centerX; endY = centerY + distance;
                    break;
                case 'left':
                    startX = centerX + distance; startY = centerY;
                    endX = centerX - distance; endY = centerY;
                    break;
                case 'right':
                    startX = centerX - distance; startY = centerY;
                    endX = centerX + distance; endY = centerY;
                    break;
            }

            const swipeData = {
                t: 'swipe',
                start_x: startX,
                start_y: startY,
                end_x: endX,
                end_y: endY,
                duration: 0.3
            };
            // Send swipe regardless of mode - always use control WebSocket
            if (controlWs) {
                controlWs.send(JSON.stringify(swipeData));
                showTemporaryStatus(`Quick swipe ${direction} performed`);
            } else {
                showTemporaryStatus(`Control connection not available`);
            }
        }

        function pressButton(button) {
            // Send button press regardless of mode - always use control WebSocket
            console.log(`Button pressed: ${button}`);
            if (controlWs) {
                controlWs.send(JSON.stringify({ t: 'button', button: button }));
                showTemporaryStatus(`${button} button pressed`);
            } else {
                showTemporaryStatus(`Control connection not available`);
            }
        }

        function sendText() {
            const text = textInput.value.trim();
            if (!text) return;

            // Send text regardless of mode - always use control WebSocket  
            if (controlWs) {
                controlWs.send(JSON.stringify({ t: 'text', text: text }));
                showTemporaryStatus(`Text sent: "${text}"`);
                textInput.value = '';
            } else {
                showTemporaryStatus(`Control connection not available`);
            }
        }

        function clearText() {
            textInput.value = '';
        }

        function showTemporaryStatus(message) {
            const oldText = status.textContent;
            const modePrefix = currentMode === 'webrtc' ? '🚀 ' :
                currentMode === 'video' ? '🎥 ' : '📷 ';
            status.textContent = modePrefix + message;
            setTimeout(() => {
                if (status.textContent === modePrefix + message) {
                    status.textContent = oldText;
                }
            }, 2000);
        }

        async function takeScreenshot() {
            if (currentMode === 'screenshot' && screenshotWs) {
                screenshotWs.send(JSON.stringify({ t: 'refresh' }));
            } else {
                showTemporaryStatus('Screenshot refresh only works in screenshot mode');
            }
        }

        async function restartPipeline() {
            status.textContent = 'Restarting stream...';
            status.className = 'disconnected';

            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            setTimeout(() => switchMode(currentMode), 1000);
        }

        async function checkStatus() {
            try {
                const resp = await fetch(`/status/${SESSION_ID}`);
                const statusData = await resp.json();

                if (statusData.status === 'healthy') {
                    status.textContent = `System healthy | Video clients: ${statusData.video_clients} | Cache age: ${statusData.cache_age?.toFixed(2)}s`;
                    status.className = 'connected';
                } else {
                    status.textContent = 'System unhealthy';
                    status.className = 'disconnected';
                }
            } catch (error) {
                status.textContent = 'Status check failed';
                status.className = 'disconnected';
            }
        }

        async function testTap() {
            if (pointWidth === 0 || pointHeight === 0) {
                status.textContent = 'No point dimensions available';
                return;
            }

            const centerX = Math.round(pointWidth / 2);
            const centerY = Math.round(pointHeight / 2);

            try {
                const resp = await fetch(`/debug/tap/${centerX}/${centerY}`);
                const result = await resp.json();

                if (result.success) {
                    showTemporaryStatus(`Test tap successful at (${centerX}, ${centerY})`);
                } else {
                    showTemporaryStatus(`Test tap failed: ${result.stderr}`);
                }
            } catch (error) {
                showTemporaryStatus('Test tap failed');
            }
        }

        async function pressVolumeButton(direction) {
            try {
                const resp = await fetch(`/debug/volume-${direction}`);
                const result = await resp.json();

                if (result.success) {
                    showTemporaryStatus(`Volume ${direction} pressed`);
                } else {
                    showTemporaryStatus(`Volume ${direction} failed: ${result.note || result.stderr}`);
                }
            } catch (error) {
                showTemporaryStatus(`Volume ${direction} failed`);
            }
        }

        async function pressShakeButton() {
            try {
                const resp = await fetch('/debug/shake');
                const result = await resp.json();

                if (result.success) {
                    showTemporaryStatus('Device shaken');
                } else {
                    showTemporaryStatus(`Shake failed: ${result.stderr}`);
                }
            } catch (error) {
                showTemporaryStatus('Shake failed');
            }
        }


        async function setupWebRTCStream() {
            status.textContent = 'Initializing high-quality WebRTC stream...';
            status.className = 'connected';

            try {
                // Create WebRTC connection with multiple ICE servers for better connectivity
                peerConnection = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' },
                        { urls: 'stun:stun.cloudflare.com:3478' },
                        { urls: 'stun:openrelay.metered.ca:80' }
                    ],
                    iceCandidatePoolSize: 10,
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require'
                });

                // Handle incoming video stream with proper sizing
                peerConnection.ontrack = (event) => {
                    console.log('WebRTC high-quality track received');
                    webrtcVideo.srcObject = event.streams[0];

                    // Wait for video metadata to load, then size it properly
                    webrtcVideo.onloadedmetadata = () => {
                        resizeWebRTCVideo();
                        setupWebRTCInteraction();

                        status.textContent = '🚀 WebRTC High-Quality Stream - 60fps Ultra Low Latency';
                        status.className = 'connected';
                    };
                };

                // ICE connection state change handler
                peerConnection.oniceconnectionstatechange = () => {
                    console.log(`🧊 ICE connection state: ${peerConnection.iceConnectionState}`);
                };

                // ICE gathering state change handler
                peerConnection.onicegatheringstatechange = () => {
                    console.log(`🔍 ICE gathering state: ${peerConnection.iceGatheringState}`);
                };

                // ICE candidate handler - send candidates to server
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log(`🧊 ICE candidate: ${event.candidate.candidate}`);
                        // Send ICE candidate to server via signaling WebSocket
                        if (webrtcWs && webrtcWs.readyState === WebSocket.OPEN) {
                            webrtcWs.send(JSON.stringify({
                                type: 'ice-candidate',
                                candidate: event.candidate
                            }));
                        }
                    } else {
                        console.log('🧊 ICE gathering completed');
                    }
                };
                // Enhanced connection state handling
                peerConnection.onconnectionstatechange = () => {
                    console.log(`🔗 WebRTC connection state: ${peerConnection.connectionState}`);

                    if (peerConnection.connectionState === 'connected') {
                        console.log('🎉 WebRTC connection established successfully');
                        startWebRTCStatsMonitoring();
                        optimizeWebRTCQuality();
                    } else if (peerConnection.connectionState === 'failed') {
                        console.error('❌ WebRTC connection failed');
                        status.textContent = 'WebRTC connection failed - retrying...';
                        status.className = 'disconnected';
                        setTimeout(() => setupWebRTCStream(), 2000);
                    }
                };

                // Set up signaling WebSocket
                webrtcWs = new WebSocket(`ws://${location.hostname}:8000/ws/${SESSION_ID}/webrtc`);

                webrtcWs.onopen = async () => {
                    console.log('📡 WebRTC signaling connected');

                    try {
                        // Send start stream request first
                        console.log('📡 Sending start-stream request');
                        webrtcWs.send(JSON.stringify({
                            type: 'start-stream',
                            quality: currentWebRTCQuality,
                            sessionId: SESSION_ID
                        }));

                        // Create offer with quality constraints
                        console.log('🔧 Creating WebRTC offer');
                        const offer = await peerConnection.createOffer({
                            offerToReceiveVideo: true,
                            offerToReceiveAudio: false,
                            voiceActivityDetection: false
                        });

                        // Enhance SDP for better quality
                        const enhancedOffer = enhanceSDPForQuality(offer);
                        await peerConnection.setLocalDescription(enhancedOffer);
                        console.log('✅ Local description set');

                        // Send enhanced offer
                        console.log('📡 Sending WebRTC offer to server');
                        webrtcWs.send(JSON.stringify({
                            type: 'offer',
                            sdp: enhancedOffer.sdp
                        }));
                        console.log('✅ WebRTC offer sent');
                    } catch (error) {
                        console.error('❌ Error during WebRTC setup:', error);
                        status.textContent = 'WebRTC setup failed';
                        status.className = 'disconnected';
                    }
                };

                webrtcWs.onmessage = async (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        console.log(`📡 WebRTC signaling received: ${data.type}`);

                        if (data.type === 'answer') {
                            console.log('🤝 Received WebRTC answer, setting remote description');
                            const enhancedAnswer = enhanceSDPForQuality({
                                type: 'answer',
                                sdp: data.sdp
                            });

                            await peerConnection.setRemoteDescription(new RTCSessionDescription(enhancedAnswer));
                            console.log('✅ WebRTC remote description set successfully');
                        } else if (data.type === 'ice-candidate') {
                            if (data.candidate) {
                                console.log(`🧊 Received server ICE candidate: ${data.candidate.candidate}`);
                                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                                console.log('✅ Server ICE candidate added successfully');
                            }
                        } else if (data.type === 'error') {
                            console.error('❌ WebRTC signaling error:', data.message);
                            status.textContent = `WebRTC error: ${data.message}`;
                            status.className = 'disconnected';
                        } else {
                            console.log(`📡 Unknown WebRTC message type: ${data.type}`, data);
                        }
                    } catch (error) {
                        console.error('❌ WebRTC signaling message error:', error);
                    }
                };

                webrtcWs.onerror = (error) => {
                    console.error('WebRTC signaling error:', error);
                    status.textContent = 'WebRTC signaling error';
                    status.className = 'disconnected';
                };

                webrtcWs.onclose = () => {
                    console.log('WebRTC signaling disconnected');
                    if (currentMode === 'webrtc') {
                        status.textContent = 'WebRTC disconnected';
                        status.className = 'disconnected';
                    }
                };

            } catch (error) {
                console.error('WebRTC setup error:', error);
                status.textContent = 'WebRTC setup failed';
                status.className = 'disconnected';
            }
        }

        function resizeWebRTCVideo() {
            if (!webrtcVideo.videoWidth || !webrtcVideo.videoHeight) return;

            const screenContainer = document.querySelector('.screen-container');
            const containerWidth = screenContainer.clientWidth - 4;
            const videoAspectRatio = webrtcVideo.videoWidth / webrtcVideo.videoHeight;

            let displayWidth = Math.min(containerWidth, 400);
            let displayHeight = displayWidth / videoAspectRatio;

            const maxHeight = window.innerHeight * 0.6;
            if (displayHeight > maxHeight) {
                displayHeight = maxHeight;
                displayWidth = displayHeight * videoAspectRatio;
            }

            webrtcVideo.style.width = Math.round(displayWidth) + 'px';
            webrtcVideo.style.height = Math.round(displayHeight) + 'px';
            webrtcVideo.style.maxWidth = '100%';
            webrtcVideo.style.maxHeight = '60vh';

            console.log(`WebRTC video sized: ${displayWidth}x${displayHeight}`);
        }
        function enhanceSDPForQuality(offer) {
            let sdp = offer.sdp;

            // Increase bitrate
            sdp = sdp.replace(/b=AS:\d+/g, `b=AS:${webrtcQualitySettings.bitrate / 1000}`);

            // Add bitrate constraints if not present
            if (!sdp.includes('b=AS:')) {
                sdp = sdp.replace(/(m=video.*)/g, `$1\r\nb=AS:${webrtcQualitySettings.bitrate / 1000}`);
            }

            // Enhance H.264 parameters for quality
            sdp = sdp.replace(
                /(a=fmtp:\d+ .*profile-level-id=42e01f)/g,
                '$1;max-br=5000;max-mbps=245760;max-fs=8160'
            );

            // Set high frame rate
            sdp = sdp.replace(/(a=framerate:)\d+/g, `$1${webrtcQualitySettings.fps}`);

            // Add frame rate if not present
            if (!sdp.includes('a=framerate:')) {
                sdp = sdp.replace(/(m=video.*)/g, `$1\r\na=framerate:${webrtcQualitySettings.fps}`);
            }

            return {
                type: offer.type,
                sdp: sdp
            };
        }


        // Function to optimize WebRTC quality after connection
        async function optimizeWebRTCQuality() {
            if (!peerConnection) return;

            try {
                const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
                if (sender) {
                    const params = sender.getParameters();

                    // Optimize encoding parameters
                    if (params.encodings && params.encodings.length > 0) {
                        params.encodings[0].maxBitrate = webrtcQualitySettings.bitrate;
                        params.encodings[0].maxFramerate = webrtcQualitySettings.fps;
                        params.encodings[0].scaleResolutionDownBy = 1; // No downscaling

                        await sender.setParameters(params);
                        console.log('WebRTC quality parameters optimized');
                    }
                }
            } catch (error) {
                console.error('Failed to optimize WebRTC quality:', error);
            }
        }

        // Update setupWebRTCInteraction to properly handle cursor changes
        function setupWebRTCInteraction() {
            // Set video dimensions for coordinate mapping
            webrtcVideo.onloadedmetadata = () => {
                pixelWidth = webrtcVideo.videoWidth;
                pixelHeight = webrtcVideo.videoHeight;
                pointWidth = 390;  // Default iOS point width
                pointHeight = 844; // Default iOS point height

                updateWebRTCInfo();
            };

            // Mouse events for WebRTC video
            webrtcVideo.onmousedown = (ev) => {
                const rect = webrtcVideo.getBoundingClientRect();
                const clickX = ev.clientX - rect.left;
                const clickY = ev.clientY - rect.top;

                if (swipeMode) {
                    swipeStart = { x: clickX, y: clickY };
                    webrtcVideo.style.cursor = 'grab';
                } else {
                    handleWebRTCTap(clickX, clickY);
                }
            };

            webrtcVideo.onmouseup = (ev) => {
                if (swipeMode && swipeStart) {
                    const rect = webrtcVideo.getBoundingClientRect();
                    const endX = ev.clientX - rect.left;
                    const endY = ev.clientY - rect.top;

                    handleWebRTCSwipe(swipeStart.x, swipeStart.y, endX, endY);
                    swipeStart = null;
                    webrtcVideo.style.cursor = 'crosshair';
                }
            };

            webrtcVideo.onmouseleave = () => {
                if (swipeMode) {
                    swipeStart = null;
                    webrtcVideo.style.cursor = 'crosshair';
                }
            };

            webrtcVideo.style.cursor = 'crosshair';
        }

        function handleWebRTCTap(clickX, clickY) {
            if (pointWidth > 0 && pointHeight > 0) {
                const rect = webrtcVideo.getBoundingClientRect();
                const displayWidth = rect.width;
                const displayHeight = rect.height;

                const tapX = Math.round((clickX / displayWidth) * pointWidth);
                const tapY = Math.round((clickY / displayHeight) * pointHeight);

                console.log(`WebRTC Tap: Display(${Math.round(clickX)}, ${Math.round(clickY)}) -> Point(${tapX}, ${tapY})`);

                // Always use control WebSocket for taps in WebRTC mode
                if (controlWs) {
                    controlWs.send(JSON.stringify({ t: 'tap', x: tapX, y: tapY }));
                    showTemporaryStatus(`WebRTC Tap: (${tapX}, ${tapY})`);
                } else {
                    showTemporaryStatus(`Control connection not available`);
                }
            }
        }

        function handleWebRTCSwipe(startX, startY, endX, endY) {
            if (pointWidth > 0 && pointHeight > 0) {
                const rect = webrtcVideo.getBoundingClientRect();
                const displayWidth = rect.width;
                const displayHeight = rect.height;

                const startPointX = Math.round((startX / displayWidth) * pointWidth);
                const startPointY = Math.round((startY / displayHeight) * pointHeight);
                const endPointX = Math.round((endX / displayWidth) * pointWidth);
                const endPointY = Math.round((endY / displayHeight) * pointHeight);

                console.log(`WebRTC Swipe: Point(${startPointX}, ${startPointY}) -> Point(${endPointX}, ${endPointY})`);

                const swipeData = {
                    t: 'swipe',
                    start_x: startPointX,
                    start_y: startPointY,
                    end_x: endPointX,
                    end_y: endPointY,
                    duration: 0.3
                };

                // Always use control WebSocket for swipes in WebRTC mode
                if (controlWs) {
                    controlWs.send(JSON.stringify(swipeData));
                    showTemporaryStatus(`WebRTC Swipe: (${startPointX}, ${startPointY}) → (${endPointX}, ${endPointY})`);
                } else {
                    showTemporaryStatus(`Control connection not available`);
                }
            }
        }

        function startWebRTCStatsMonitoring() {
            if (!peerConnection) return;

            let statsInterval = setInterval(async () => {
                if (!peerConnection || peerConnection.connectionState !== 'connected') {
                    clearInterval(statsInterval);
                    return;
                }

                try {
                    const stats = await peerConnection.getStats();

                    stats.forEach(report => {
                        if (report.type === 'inbound-rtp' && report.mediaType === 'video') {
                            const now = Date.now();
                            const deltaTime = (now - webrtcStats.lastStatsTime) / 1000;

                            if (webrtcStats.lastStatsTime > 0 && deltaTime > 0) {
                                const deltaFrames = report.framesReceived - webrtcStats.framesReceived;
                                const deltaBytes = report.bytesReceived - webrtcStats.bytesReceived;

                                webrtcStats.fps = Math.round(deltaFrames / deltaTime);
                                webrtcStats.bitrate = Math.round((deltaBytes * 8) / deltaTime / 1000); // kbps
                                webrtcStats.resolution = `${report.frameWidth}x${report.frameHeight}`;
                                webrtcStats.framesDropped = report.framesDropped || 0;
                                webrtcStats.jitter = report.jitter || 0;
                            }

                            webrtcStats.framesReceived = report.framesReceived;
                            webrtcStats.bytesReceived = report.bytesReceived;
                            webrtcStats.lastStatsTime = now;

                            updateWebRTCInfo();
                        }
                    });
                } catch (error) {
                    console.error('WebRTC stats error:', error);
                }
            }, 1000);
        }

        function updateWebRTCInfo() {
            if (currentMode !== 'webrtc') return;

            const fps = webrtcStats.fps || 0;
            const bitrate = webrtcStats.bitrate || 0;
            const resolution = webrtcStats.resolution || `${pixelWidth}×${pixelHeight}`;
            const dropped = webrtcStats.framesDropped || 0;

            dimensionInfo.textContent = `WebRTC: ${resolution} | Points: ${pointWidth}×${pointHeight} | ${bitrate}kbps`;

            let latencyClass = 'latency-low';
            let latencyText = 'Ultra Low';
            let qualityText = 'Excellent';

            // Determine quality based on FPS and bitrate
            if (fps >= 55 && bitrate >= 3000) {
                qualityText = 'Ultra High';
                latencyClass = 'latency-low';
            } else if (fps >= 45 && bitrate >= 2000) {
                qualityText = 'High';
                latencyClass = 'latency-low';
            } else if (fps >= 30 && bitrate >= 1000) {
                qualityText = 'Good';
                latencyClass = 'latency-medium';
            } else {
                qualityText = 'Fair';
                latencyClass = 'latency-high';
                latencyText = 'Medium';
            }

            qualityInfo.textContent = `FPS: ${fps} | Quality: ${qualityText} | Dropped: ${dropped}`;
            latencyInfo.innerHTML = `<span class="latency-indicator ${latencyClass}"></span>Latency: ${latencyText}`;
        }

        function setWebRTCQuality(preset) {
            const presets = {
                'low': { fps: 30, bitrate: 1500000 },      // 1.5 Mbps, 30fps
                'medium': { fps: 45, bitrate: 3000000 },   // 3 Mbps, 45fps  
                'high': { fps: 60, bitrate: 5000000 },     // 5 Mbps, 60fps
                'ultra': { fps: 60, bitrate: 8000000 }     // 8 Mbps, 60fps
            };

            if (presets[preset]) {
                webrtcQualitySettings = presets[preset];
                currentWebRTCQuality = preset;

                // Update button highlighting
                updateWebRTCQualityButtonHighlight(preset);

                // Apply immediately if connected
                if (peerConnection && peerConnection.connectionState === 'connected') {
                    optimizeWebRTCQuality();
                }

                showTemporaryStatus(`WebRTC quality set to ${preset.toUpperCase()}`);
            }
        }

        function updateWebRTCQualityButtonHighlight(selectedQuality) {
            // Remove active class from all WebRTC quality buttons
            const webrtcQualitySection = document.getElementById('webrtc-quality-section');
            const qualityButtons = webrtcQualitySection.querySelectorAll('button');

            qualityButtons.forEach(button => {
                button.classList.remove('active');
            });

            // Add active class to selected quality button based on text content
            qualityButtons.forEach(button => {
                const buttonText = button.textContent.toLowerCase();
                if (buttonText.includes(selectedQuality)) {
                    button.classList.add('active');
                }
            });
        }

        // Add these functions to your existing JavaScript section

        async function openUrl() {
            const urlInput = document.getElementById('urlInput');
            const url = urlInput.value.trim();

            if (!url) {
                showTemporaryStatus('Please enter a URL');
                return;
            }

            try {
                showTemporaryStatus(`Opening URL: ${url}`);

                const formData = new FormData();
                formData.append('url', url);

                const response = await fetch(`/api/sessions/${SESSION_ID}/url/open`, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (data.success) {
                    showTemporaryStatus(`✅ URL opened successfully: ${url}`);
                    // Don't clear the input in case user wants to try variations
                } else {
                    showTemporaryStatus(`❌ Failed to open URL: ${data.message || 'Unknown error'}`);
                }

            } catch (error) {
                console.error('Failed to open URL:', error);
                showTemporaryStatus(`❌ Failed to open URL: ${error.message}`);
            }
        }

        function showUrlExamples() {
            const examplesDiv = document.getElementById('urlExamples');
            if (examplesDiv.style.display === 'none') {
                examplesDiv.style.display = 'block';
            } else {
                examplesDiv.style.display = 'none';
            }
        }

        function fillUrlExample(exampleUrl) {
            const urlInput = document.getElementById('urlInput');
            urlInput.value = exampleUrl;
            urlInput.focus();

            // Hide examples after selection
            document.getElementById('urlExamples').style.display = 'none';
        }

        // Add keyboard shortcut for URL opening
        document.addEventListener('keydown', (e) => {
            const urlInput = document.getElementById('urlInput');

            // If URL input is focused and Enter is pressed, open the URL
            if (e.target === urlInput && e.key === 'Enter') {
                openUrl();
                e.preventDefault();
            }

            // Add 'u' key shortcut to focus URL input (when not in text input)
            if (e.target !== textInput && e.target !== urlInput && e.key === 'u') {
                urlInput.focus();
                e.preventDefault();
            }
        });

        // Optional: Add URL validation and suggestions
        function validateAndSuggestUrl(url) {
            const urlInput = document.getElementById('urlInput');

            // Auto-add https:// for simple domains
            if (url && !url.includes('://') && !url.includes('@') && url.includes('.')) {
                if (!url.match(/^[a-z]+:/)) {
                    return 'https://' + url;
                }
            }

            return url;
        }

        // Add input event listener for URL suggestions
        document.addEventListener('DOMContentLoaded', () => {
            const urlInput = document.getElementById('urlInput');
            if (urlInput) {
                urlInput.addEventListener('blur', (e) => {
                    const suggestedUrl = validateAndSuggestUrl(e.target.value);
                    if (suggestedUrl !== e.target.value) {
                        e.target.value = suggestedUrl;
                    }
                });
            }
        });

        document.addEventListener('DOMContentLoaded', function () {
            console.log('DOM loaded, checking DeviceLogsManager...');
            if (typeof DeviceLogsManager === 'undefined') {
                console.error('❌ DeviceLogsManager not found - logs.js failed to load');

                // Try to load it again
                const script = document.createElement('script');
                script.src = '/static/js/logs.js';
                script.onload = function () {
                    console.log('✅ logs.js loaded successfully on retry');
                    if (typeof DeviceLogsManager !== 'undefined') {
                        initLogViewer();
                    }
                };
                script.onerror = function () {
                    console.error('❌ Failed to load logs.js even on retry');
                };
                document.head.appendChild(script);
            } else {
                console.log('✅ DeviceLogsManager found successfully');
            }
        });

        let appsListCollapsed = false;

        function toggleAppsSection() {
            const appsListSection = document.getElementById('appsListSection');
            const toggleIcon = document.getElementById('appsToggleIcon');

            appsListCollapsed = !appsListCollapsed;

            if (appsListCollapsed) {
                // Collapse
                appsListSection.classList.add('collapsed');
                toggleIcon.classList.add('collapsed');
                toggleIcon.textContent = '▶';

                // Update status
                showTemporaryStatus('📱 Apps list collapsed');

                // Store preference in localStorage
                localStorage.setItem('appsListCollapsed', 'true');
            } else {
                // Expand
                appsListSection.classList.remove('collapsed');
                toggleIcon.classList.remove('collapsed');
                toggleIcon.textContent = '▼';

                // Update status
                showTemporaryStatus('📱 Apps list expanded');

                // Store preference in localStorage
                localStorage.setItem('appsListCollapsed', 'false');

                // Refresh apps when expanding
                if (installedApps.length === 0) {
                    loadInstalledApps();
                }
            }
        }

        // Load collapsed state from localStorage on page load
        function loadAppsListState() {
            const savedState = localStorage.getItem('appsListCollapsed');
            if (savedState === 'true') {
                // Delay to ensure elements are loaded
                setTimeout(() => {
                    toggleAppsSection();
                }, 100);
            }
        }

        // Update the init function to load the saved state
        function init() {
            setupControlWebSocket();
            setupKeyboardShortcuts();
            switchMode('video');
            loadInstalledApps();
            loadAppsListState(); // Add this line

            setTimeout(() => {
                console.log('Starting subsystem initialization...');

                // Initialize logs
                if (typeof initLogViewer === 'function') {
                    initLogViewer();
                }

                // Initialize location controls
                if (typeof initLocationControls === 'function') {
                    initLocationControls();
                }

                // Initialize media transfer
                initMediaTransfer();

            }, 1500);
        }

        window.testWebSocketConnection = testWebSocketConnection;


        // Handle window resize to maintain aspect ratio
        window.addEventListener('resize', () => {
            if (currentMode === 'webrtc' && webrtcVideo.videoWidth > 0) {
                resizeWebRTCVideo();
            } else if (currentMode === 'video' && pixelWidth > 0) {
                // Trigger a resize recalculation
                setTimeout(() => {
                    const img = new Image();
                    img.onload = () => {
                        const containerWidth = canvas.parentElement.clientWidth - 24;
                        const devicePixelRatio = window.devicePixelRatio || 1;
                        const aspectRatio = pixelWidth / pixelHeight;

                        let displayWidth = Math.min(containerWidth, 450);
                        let displayHeight = displayWidth / aspectRatio;

                        const maxHeight = window.innerHeight * 0.7;
                        if (displayHeight > maxHeight) {
                            displayHeight = maxHeight;
                            displayWidth = displayHeight * aspectRatio;
                        }

                        displayWidth = Math.round(displayWidth);
                        displayHeight = Math.round(displayHeight);

                        canvas.width = displayWidth * devicePixelRatio;
                        canvas.height = displayHeight * devicePixelRatio;
                        canvas.style.width = displayWidth + 'px';
                        canvas.style.height = displayHeight + 'px';

                        ctx.scale(devicePixelRatio, devicePixelRatio);
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.clearRect(0, 0, displayWidth, displayHeight);
                        ctx.drawImage(img, 0, 0, displayWidth, displayHeight);

                        dimensionInfo.textContent = `Pixels: ${pixelWidth}×${pixelHeight} | Points: ${pointWidth}×${pointHeight} | Display: ${displayWidth}×${displayHeight}`;
                    };
                    img.src = canvas.toDataURL();
                }, 100);
            }
        });


        async function getAppContainer() {
            const bundleId = prompt('Enter app bundle ID:');
            if (!bundleId) return;

            if (window.mediaTransferManager) {
                const containerPath = await window.mediaTransferManager.getAppContainerPath(bundleId);
                if (containerPath) {
                    showTemporaryStatus(`📱 App container: ${containerPath}`);
                    // Fill in the inputs
                    const pushBundleInput = document.getElementById('bundleIdInput');
                    const pullBundleInput = document.getElementById('pullBundleIdInput');

                    if (pushBundleInput) pushBundleInput.value = bundleId;
                    if (pullBundleInput) pullBundleInput.value = bundleId;
                }
            }
        }

        // Initialize media transfer manager
        function initMediaTransfer() {
            if (window.mediaTransferManager && !window.mediaTransferManager.initialized) {
                window.mediaTransferManager.init();
                window.mediaTransferManager.initialized = true;
                console.log('Media transfer manager initialized');
            }
        }

        // Call this in your main init function
        setTimeout(() => {
            initMediaTransfer();
        }, 1000);
    </script>
</body>

</html>